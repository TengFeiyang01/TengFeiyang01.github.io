<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Raft | ytfの博客</title><meta name="author" content="ytf"><meta name="copyright" content="ytf"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Raft分布式共识算法一个 Raft 实例（Raft Peer）的主要有三个工作流：  领导选举（leader election） 日志同步（ log replication） 日志应用（log application）  PartA 领导选举实现 Raft 选举和心跳逻辑（即不带日志条目的 AppendEntries）。本部分仅要求实现：  选出唯一的领导者，领导者选出后会持续进行心跳避免其他人">
<meta property="og:type" content="article">
<meta property="og:title" content="Raft">
<meta property="og:url" content="http://example.com/2024/02/06/raft/index.html">
<meta property="og:site_name" content="ytfの博客">
<meta property="og:description" content="Raft分布式共识算法一个 Raft 实例（Raft Peer）的主要有三个工作流：  领导选举（leader election） 日志同步（ log replication） 日志应用（log application）  PartA 领导选举实现 Raft 选举和心跳逻辑（即不带日志条目的 AppendEntries）。本部分仅要求实现：  选出唯一的领导者，领导者选出后会持续进行心跳避免其他人">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.freeimg.cn/i/2024/03/01/65e19472e086e.webp">
<meta property="article:published_time" content="2024-02-06T04:54:51.000Z">
<meta property="article:modified_time" content="2024-03-01T08:40:27.821Z">
<meta property="article:author" content="ytf">
<meta property="article:tag" content="Mit6.5840">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.freeimg.cn/i/2024/03/01/65e19472e086e.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/02/06/raft/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Raft',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-03-01 16:40:27'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic1.zhimg.com/80/v2-5454ebb88b238dfaf564313089962dc8_1440w.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="ytfの博客"><img class="site-icon" src="https://www.freeimg.cn/i/2024/02/29/65e066f56949c.jpg"/><span class="site-name">ytfの博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Raft</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-06T04:54:51.000Z" title="发表于 2024-02-06 12:54:51">2024-02-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-01T08:40:27.821Z" title="更新于 2024-03-01 16:40:27">2024-03-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Raft"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Raft分布式共识算法"><a href="#Raft分布式共识算法" class="headerlink" title="Raft分布式共识算法"></a>Raft分布式共识算法</h1><p>一个 Raft 实例（Raft Peer）的主要有三个工作流：</p>
<ol>
<li>领导选举（leader election）</li>
<li>日志同步（ log replication）</li>
<li>日志应用（log application）</li>
</ol>
<h1 id="PartA-领导选举"><a href="#PartA-领导选举" class="headerlink" title="PartA 领导选举"></a>PartA 领导选举</h1><p>实现 Raft 选举和<strong>心跳逻辑</strong>（即不带日志条目的 AppendEntries）。本部分仅要求实现：</p>
<ol>
<li>选出<strong>唯一</strong>的领导者，领导者选出后会持续进行心跳避免其他人发起选举</li>
<li>旧的领导者宕机或者网络故障无法触达时，选出<strong>新的</strong>领导者</li>
</ol>
<p>我们可以将 PartA 的实现分为三部分：</p>
<ol>
<li><strong>状态转换</strong>：角色定义和三个状态转换函数</li>
<li><strong>选举逻辑</strong>：定义选举 RPC 相关结构体，构造周期性发送请求的 Loop</li>
<li><strong>心跳逻辑</strong>：定义心跳 RPC 相关结构体（只有心跳，因此不涉及日志），当选 Leader 后发送心跳</li>
</ol>
<p>在开始实现逻辑之前，要根据论文图 2 定义 Raft 用到的基本数据结构，如前所述，PartA 暂时不用管日志相关字段和逻辑。下面代码中，上面部分是代码框架为了测试默认给的，加粗部分是本部分新加的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Go object implementing a single Raft peer.</span></span><br><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">        mu        sync.Mutex          <span class="comment">// Lock to protect shared access to this peer&#x27;s state</span></span><br><span class="line">        peers     []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">        persister *Persister          <span class="comment">// Object to hold this peer&#x27;s persisted state</span></span><br><span class="line">        me        <span class="type">int</span>                 <span class="comment">// this peer&#x27;s index into peers[]</span></span><br><span class="line">        dead      <span class="type">int32</span>               <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Your data here (PartA, PartB, PartC).</span></span><br><span class="line">        <span class="comment">// Look at the paper&#x27;s Figure 2 for a description of what</span></span><br><span class="line">        <span class="comment">// state a Raft server must maintain.</span></span><br><span class="line">        role        Role</span><br><span class="line">        currentTerm <span class="type">int</span></span><br><span class="line">        votedFor     <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// used for election loop</span></span><br><span class="line">        electionStart   time.Time</span><br><span class="line">        electionTimeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：在工程实践中，<code>currentTerm</code> 一般会建议用指定位数的整形，比如 <code>int32</code>，但这里为了简单就直接用 <code>int</code> 了。</p>
<p>修改关键函数 <code>GetState</code>，是测试框架能够正确拿到 Raft 相关状态，否则可能会出现测试框架认为一直选不出主的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return currentTerm and whether this server</span></span><br><span class="line"><span class="comment">// believes it is the leader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> GetState() (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">        <span class="comment">// Your code here (PartA).</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> rf.currentTerm, rf.role == Leader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><p>状态转换是针对 Peer 角色的，因此需要先定义<strong>角色类型</strong>和<strong>常量</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Role <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        Follower  Role = <span class="string">&quot;Follower&quot;</span></span><br><span class="line">        Candidate Role = <span class="string">&quot;Candidate&quot;</span></span><br><span class="line">        Leader    Role = <span class="string">&quot;Leader&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在此之上，参考论文中的状态机构建状态转换函数。 </p>
<p><img src="https://www.freeimg.cn/i/2024/02/05/65c088ce75624.png"></p>
<p>可以实现为三个状态转换函数：<code>becomeCandidate</code>，<code>becomeLeader</code> 和 <code>becomeFollower</code>。由于涉及修改 Raft 的全局状态，需要加锁，且我们期望在函数外边加锁。按照之前提到的命名规则，对每个函数需要带上 <code>Locked</code> 后缀，表明需要在加锁的临界区中调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// become a follower in `term`, term could not be decreased</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeFollowerLocked(term <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> term &lt; rf.currentTerm &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DError, <span class="string">&quot;Can&#x27;t become Follower, lower term&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;%s -&gt; Follower, For T%d-&gt;T%d&quot;</span>, </span><br><span class="line">            rf.role, rf.currentTerm, term)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// important! Could only reset the `votedFor` when term increased</span></span><br><span class="line">        <span class="keyword">if</span> term &gt; rf.currentTerm &#123; </span><br><span class="line">                rf.votedFor = <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.role = Follower</span><br><span class="line">        rf.currentTerm = term</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeCandidateLocked() &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.role == Leader &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DError, <span class="string">&quot;Leader can&#x27;t become Candidate&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;%s -&gt; Candidate, For T%d-&gt;T%d&quot;</span>, </span><br><span class="line">            rf.role, rf.currentTerm, rf.currentTerm+<span class="number">1</span>)</span><br><span class="line">        rf.role = Candidate</span><br><span class="line">        rf.currentTerm++</span><br><span class="line">    	rf.resetElectionTimerLocked()</span><br><span class="line">        rf.votedFor = rf.me</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeLeaderLocked() &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.role != Candidate &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLeader, </span><br><span class="line">                    <span class="string">&quot;%s, Only candidate can become Leader&quot;</span>, rf.role)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DLeader, <span class="string">&quot;%s -&gt; Leader, For T%d&quot;</span>, </span><br><span class="line">            rf.role, rf.currentTerm)</span><br><span class="line">        rf.role = Leader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，每个状态转换函数可分为两部分：</p>
<ol>
<li><strong>状态检查</strong>：检查 Raft 实例当前状态，看是否满足状态转换条件。</li>
<li><strong>状态修改</strong>：修改 Raft 实例角色，更改相应状态。</li>
</ol>
<h2 id="选举逻辑"><a href="#选举逻辑" class="headerlink" title="选举逻辑"></a>选举逻辑</h2><p>我们以三个层次组织 RPC <strong>发送方</strong>（也就是 Candidate）<strong>要票逻辑</strong>：</p>
<ol>
<li><strong>选举 loop</strong>：但按框架默认的命名方式，我们称之为 <code>electionTicketor</code></li>
<li><strong>单轮选举</strong>：超时成为 Candidate 之后，针对所有 Peer（除自己外）发起一次要票过程，我们称之为 <code>startElection</code>。</li>
<li><strong>单次 RPC</strong>：针对每个 Peer 的 RequestVote 的请求和响应处理，由于要进行计票，需要用到一个局部变量 votes，因此我们使用一个<code>startElection</code> 中的嵌套函数来实现，称为 <code>askVoteFromPeer</code>。</li>
</ol>
<p>还剩一块，就是 RPC <strong>接受方</strong>（其他 Peer）的<strong>投票逻辑</strong>。</p>
<h3 id="选举-loop"><a href="#选举-loop" class="headerlink" title="选举 loop"></a>选举 loop</h3><p>基本逻辑是每次循环时，要进行两项检查：</p>
<ol>
<li>超时检查：看<strong>选举 Timer</strong> 是否已经超时，只有超时后才会真正发起选举。这里有个问题，就是为什么检查间隔（也就是循环中的 <code>time.Sleep(time.Duration(ms) * time.Millisecond)</code> ）间隔也是随机的？因为只有检查间隔也随机才不会造成：超时间隔随机，但由于“等距”检查，造成同样检查间隔时，一同发起选举。</li>
<li><strong>角色检查</strong>：判断是否为 Leader，如果自己已经是 Leader，则自然不用发起选举。因为发起选举的<strong>唯一目的就是当选 Leader</strong>。</li>
</ol>
<p>因此，我们要实现的第一个逻辑就是：随机超时上下界配置和超时检测函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        electionTimeoutMin time.Duration = <span class="number">250</span> * time.Millisecond</span><br><span class="line">        electionTimeoutMax time.Duration = <span class="number">400</span> * time.Millisecond</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> resetElectionTimerLocked() &#123;</span><br><span class="line">        rf.electionStart = time.Now()</span><br><span class="line">        randRange := <span class="type">int64</span>(electionTimeoutMax - electionTimeoutMin)</span><br><span class="line">        rf.electionTimeout = electionTimeoutMin + time.Duration(rand.Int63()%randRange)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> isElectionTimeoutLocked() <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> time.Since(rf.electionStart) &gt; rf.electionTimeout</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>满足条件时，转变为 Candidate ，然后异步地（同步会造成主 Loop 检查延迟）发起选举。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> electionTicker() &#123;</span><br><span class="line">        <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">                <span class="comment">// Your code here (PartA)</span></span><br><span class="line">                <span class="comment">// Check if a leader election should be started.</span></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                <span class="keyword">if</span> rf.role != Leader &amp;&amp; rf.isElectionTimeoutLocked() &#123;</span><br><span class="line">                        rf.becomeCandidateLocked()</span><br><span class="line">                        <span class="keyword">go</span> rf.startElection(rf.currentTerm)</span><br><span class="line">                &#125;</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// pause for a random amount of time between 50 and 350</span></span><br><span class="line">                <span class="comment">// milliseconds.</span></span><br><span class="line">                ms := <span class="number">50</span> + (rand.Int63() % <span class="number">300</span>)</span><br><span class="line">                time.Sleep(time.Duration(ms) * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有用到 Raft 全局变量的地方都要加锁，但注意不要在加锁时进行<strong>同步地</strong>发送RPC。</p>
<p>该 Loop 的生命周期和 Raft Peer 相同，即<strong>在创建 Raft 实例时就在后台开始运行</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span></span> *Raft &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// some code are omitted here</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// start ticker goroutine to start elections</span></span><br><span class="line">        <span class="keyword">go</span> rf.electionTicker()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单轮选举"><a href="#单轮选举" class="headerlink" title="单轮选举"></a>单轮选举</h3><p>一轮选举包括针对除自己外所有 Peer 的一轮要票 RPC，由于需要访问全局变量，所以仍然要加锁。同样的，就不能在持有锁的时候，同步地进行 RPC。需要用 goroutine 异步地对每个 Peer 进行 RPC。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startElection(term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        votes := <span class="number">0</span></span><br><span class="line">        askVoteFromPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *RequestVoteArgs)</span></span> &#123;</span><br><span class="line">            <span class="comment">// send rpc to `peer` and handle the response</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// every time locked </span></span><br><span class="line">        <span class="keyword">if</span> rf.contextLostLocked(Candidate, term) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                <span class="keyword">if</span> peer == rf.me &#123;</span><br><span class="line">                        votes++</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                args := &amp;RequestVoteArgs&#123;</span><br><span class="line">                        Term:        term,</span><br><span class="line">                        CandidateId: rf.me,</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">go</span> askVoteFromPeer(peer, args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="上下文检查"><a href="#上下文检查" class="headerlink" title="上下文检查"></a>上下文检查</h4><p>这里面有个检查“上下文”是否丢失的关键函数：<code>contextLostLocked</code> <strong>。上下文</strong>，在不同的地方有不同的指代。在我们的 Raft 的实现中，“上下文”就是指 <code>Term</code> 和 <code>Role</code>。即在一个任期内，只要你的角色没有变化，就能放心地<strong>推进状态机</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> contextLostLocked(role Role, term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(rf.currentTerm == term &amp;&amp; rf.role == role)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多线程环境中，只有通过锁保护起来的<strong>临界区</strong>内的代码块才可以认为被原子地执行了。由于在 Raft 实现中，我们使用了大量的 goroutine，因此每当线程新进入一个临界区时，要进行 Raft 上下文的检查。如果 Raft 的上下文已经被更改，要及时终止 goroutine，避免对状态机做出错误的改动。</p>
<h3 id="单次-RPC"><a href="#单次-RPC" class="headerlink" title="单次 RPC"></a>单次 RPC</h3><p>单次 RPC 包括<strong>构造 RPC 参数、发送 RPC等待结果、对 RPC 结果进行处理</strong>三个部分。构造参数我们在 <code>startElection</code> 函数内完成了，因此 <code>askVoteFromPeer</code> 函数中就只需要包括后梁部分即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">askVoteFromPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *RequestVoteArgs)</span></span> &#123;</span><br><span class="line">        <span class="comment">// send RPC </span></span><br><span class="line">        reply := &amp;RequestVoteReply&#123;&#125;</span><br><span class="line">        ok := rf.sendRequestVote(peer, args, reply)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// handle the response</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;Ask vote from %d, Lost or error&quot;</span>, peer)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(reply.Term)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check the context</span></span><br><span class="line">        <span class="keyword">if</span> rf.contextLostLocked(Candidate, rf.currentTerm) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;Lost context, abort RequestVoteReply in T%d&quot;</span>, rf.currentTerm)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// count votes</span></span><br><span class="line">        <span class="keyword">if</span> reply.VoteGranted &#123;</span><br><span class="line">                votes++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> votes &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">                rf.becomeLeaderLocked()</span><br><span class="line">                <span class="keyword">go</span> rf.replicationTicker(term)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对齐任期"><a href="#对齐任期" class="headerlink" title="对齐任期"></a>对齐任期</h4><p>在接受到 RPC 或者处理 RPC 返回值时的第一步，就是要<strong>对齐 Term</strong>。因为 Term 在 Raft 中本质上是一种“优先级”或者“权力等级”的体现。<strong>Peer 的 Term 相同，是对话展开的基础</strong>，否则就要先对齐 Term：</p>
<ol>
<li><strong>如果对方 Term 比自己小</strong>：无视请求，通过返回值“亮出”自己的 Term</li>
<li><strong>如果对方 Term 比自己大</strong>：乖乖跟上对方 Term，变成最“菜”的 Follower</li>
</ol>
<p>对齐 Term 之后，还要检查上下文，即处理 RPC （RPC 回调函数也是在其他线程调用的）返回值和处理多线程本质上一样：都要首先确保<strong>上下文</strong>没有丢失，才能驱动状态机。</p>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>所有 Peer 在运行时都有可能收到要票请求，<code>RequestVote</code> 这个回调函数，就是定义该 Peer 收到要票请求的处理逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">        <span class="comment">// Your code here (PartA, PartB).</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        <span class="keyword">if</span> rf.currentTerm &gt; args.Term &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;-&gt; S%d, Reject vote, higher term, T%d&gt;T%d&quot;</span>, args.CandidateId, rf.currentTerm, args.Term)</span><br><span class="line">                reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> rf.currentTerm &lt; args.Term &#123;</span><br><span class="line">                rf.becomeFollowerLocked(args.Term)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check the votedFor</span></span><br><span class="line">        <span class="keyword">if</span> rf.votedFor != <span class="number">-1</span> &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;-&gt; S%d, Reject, Already voted S%d&quot;</span>, args.CandidateId, rf.votedFor)</span><br><span class="line">                reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">        rf.votedFor = args.CandidateId</span><br><span class="line">        rf.resetElectionTimerLocked()</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;-&gt; S%d&quot;</span>, args.CandidateId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="心跳逻辑"><a href="#心跳逻辑" class="headerlink" title="心跳逻辑"></a>心跳逻辑</h2><p>和选举逻辑相对，我们分三个层次来实现 RPC <strong>发送方</strong>：</p>
<ol>
<li><strong>心跳 Loop</strong>：在当选 Leader 后起一个后台线程，等间隔的发送心跳&#x2F;复制日志，称为 <code>replicationTicker</code></li>
<li><strong>单轮心跳</strong>：对除自己外的所有 Peer 发送一个心跳 RPC，称为 <code>startReplication</code></li>
<li><strong>单次 RPC</strong>：对某个 Peer 来发送心跳，并且处理 RPC 返回值，称为 <code>replicateToPeer</code></li>
</ol>
<p>当然，还有 RPC 接收方回调函数的逻辑。</p>
<p>心跳（日志复制）逻辑和选举逻辑实现层次一致、命名风格一致的好处在于，可以减少心智负担，方便调试和维护。</p>
<h3 id="心跳-Loop"><a href="#心跳-Loop" class="headerlink" title="心跳 Loop"></a>心跳 Loop</h3><p>由于不用构造<strong>随机</strong>超时间隔，心跳 Loop 会比选举 Loop 简单很多：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicationTicker(term <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">                ok := rf.startReplication(term)</span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                time.Sleep(replicateInterval)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与选举 Loop 不同的是，这里的 <code>startReplication</code> 有个返回值，主要是检测<strong>上下文</strong>是否还在（ <code>ContextLost</code> ）——一旦发现 Raft Peer 已经不是这个 term 的 Leader 了，就立即退出 Loop。</p>
<h3 id="单轮心跳"><a href="#单轮心跳" class="headerlink" title="单轮心跳"></a>单轮心跳</h3><p>和 Candidate 的选举逻辑相似，Leader 会给除自己之外的其他 Peer 发送心跳。在发送前要检测<strong>上下文</strong>是否还在，如果不在，直接返回 false ——告诉外层循环 <code>replicationTicker</code> 可以终止循环了。</p>
<p>因为 <code>startReplication</code> 的返回值的含义为：是否成功的发起了一轮心跳。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startReplication(term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">                <span class="comment">// send heartbeat RPC and handle the reply</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> rf.contextLostLocked(Leader, term) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLeader, <span class="string">&quot;Leader[T%d] -&gt; %s[T%d]&quot;</span>, term, rf.role, rf.currentTerm)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                <span class="keyword">if</span> peer == rf.me &#123;</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">                        Term:     term,</span><br><span class="line">                        LeaderId: rf.me,</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">go</span> replicateToPeer(peer, args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单次-RPC-1"><a href="#单次-RPC-1" class="headerlink" title="单次 RPC"></a>单次 RPC</h3><p>在不关心日志时，心跳的返回值处理比较简单，只需要对齐下 term 就行。如果后续还要进行其他处理，则还要检查 context 是否丢失。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">        reply := &amp;AppendEntriesReply&#123;&#125;</span><br><span class="line">        ok := rf.sendAppendEntries(peer, args, reply)</span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;-&gt; S%d, Lost or crashed&quot;</span>, peer)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(reply.Term)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="回调函数-1"><a href="#回调函数-1" class="headerlink" title="回调函数"></a>回调函数</h4><p>心跳接收方在收到心跳时，只要 Leader 的 term 不小于自己，就对其进行认可，变为 Follower，并重置选举时钟，承诺一段时间内不发起选举。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;&lt;- S%d, Reject log&quot;</span>, args.LeaderId)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> args.Term &gt;= rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(args.Term)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reset the timer</span></span><br><span class="line">        rf.resetElectionTimerLocked()</span><br><span class="line">        reply.Success = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h2><ol>
<li><p>不要忘记实现 <code>GetState()</code> 函数，否则 tester 没有办法知道选出了 Leader。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> GetState() (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">    	rf.mu.Lock()</span><br><span class="line">    	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// Your code here (PartA).</span></span><br><span class="line">    	<span class="keyword">return</span> rf.currentTerm, rf.role == Leader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RPC 字段：golang 在进行 RPC 时，只会序列化所有大写字母开头的字段，因此一定要注意在定义 <code>*Args</code> （如 <code>RequestVoteArgs</code>）和  <code>*Reply</code> 结构体的时候，确保所有字段首字母都是大写的，否则没有办法通过 RPC 传到对端 Peer。</p>
</li>
<li><p><strong>随机超时</strong>：论文中着重强调了，为了避免“活锁”——每个人都不断地选自己，需要让选举超时是随机的。可以使用 golang 的 <a target="_blank" rel="noopener" href="https://pkg.go.dev/math/rand">rand</a> 包来制造随机超时。</p>
</li>
</ol>
<h1 id="PartB-日志同步"><a href="#PartB-日志同步" class="headerlink" title="PartB 日志同步"></a>PartB 日志同步</h1><h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p>PartB 需要定义日志格式，然后在 PartA 心跳逻辑的基础上，补全日志同步的逻辑。总体上来说，Leader 需要维护一个各个 Peer 的进度视图（<code>nextIndex</code> 和 <code>matchIndex</code> 数组）。其中 <code>nextIndex</code> 用于进行<strong>日志同步时</strong>的<strong>匹配点试探</strong>，<code>matchIndex</code> 用于<strong>日志同步成功后</strong>的<strong>匹配点记录</strong>。依据全局匹配点分布，我们可以计算出当前全局的 <code>commitIndex</code>，然后再通过之后轮次的日志复制 RPC 下发给各个 Follower。</p>
<p>每个 Follower 收到 <code>commitIndex</code> 之后，再去 apply 本地的已提交日志到状态机。</p>
<h3 id="结构体完善"><a href="#结构体完善" class="headerlink" title="结构体完善"></a>结构体完善</h3><h4 id="AppendEntries-RPC-结构体"><a href="#AppendEntries-RPC-结构体" class="headerlink" title="AppendEntries RPC 结构体"></a>AppendEntries RPC 结构体</h4><p>根据 <code>ApplyMsg</code> 所需字段，来定义 <code>LogEntry</code> 。然后在此基础上，依照 <a target="_blank" rel="noopener" href="https://raft.github.io/raft.pdf">Raft 论文</a>中的<a target="_blank" rel="noopener" href="https://av6huf2e1k.feishu.cn/docx/JCssdlgF4oRADcxxLqncPpRCn5b#TFfsdXb3boLjVQxpprMcRNHonge">图 2</a>来补全 RPC 涉及到的结构体：<code>AppendEntriesArgs</code> ，<code>AppendEntriesReply</code> 并不需要添加额外字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add log entries according to the ApplyMsg struct</span></span><br><span class="line"><span class="keyword">type</span> LogEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">        Term         <span class="type">int</span></span><br><span class="line">        CommandValid <span class="type">bool</span></span><br><span class="line">        Command      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add the fields about log: </span></span><br><span class="line"><span class="comment">// PrevLogIndex and PrevLogTerm is used to match the log prefix</span></span><br><span class="line"><span class="comment">// Entries is used to append when matched</span></span><br><span class="line"><span class="comment">// LeaderCommit tells the follower to update its own commitIndex</span></span><br><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">        Term     <span class="type">int</span></span><br><span class="line">        LeaderId <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        PrevLogIndex <span class="type">int</span></span><br><span class="line">        PrevLogTerm  <span class="type">int</span></span><br><span class="line">        Entries      []LogEntry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line">        Term    <span class="type">int</span></span><br><span class="line">        Success <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Raft-结构体"><a href="#Raft-结构体" class="headerlink" title="Raft 结构体"></a>Raft 结构体</h4><p>定义了 <code>LogEntry</code> 之后，完善下 raft struct 中相关字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log in Peer&#x27;s local</span></span><br><span class="line">log         []LogEntry</span><br><span class="line"></span><br><span class="line"><span class="comment">// only used when it is Leader,</span></span><br><span class="line"><span class="comment">// log view for each peer</span></span><br><span class="line">nextIndex  []<span class="type">int</span></span><br><span class="line">matchIndex []<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>则 <code>Make</code> 函数也要给上述字段进行初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span></span> *Raft &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log, LogEntry&#123;&#125;)</span><br><span class="line"></span><br><span class="line">        rf.matchIndex = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(rf.peers))</span><br><span class="line">        rf.nextIndex = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(rf.peers))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PC-接收方"><a href="#PC-接收方" class="headerlink" title="PC 接收方"></a>PC 接收方</h3><p>RPC 接收方，即 Leader 以外的其他 Peer。在考虑日志之后，要<strong>增加</strong>以下逻辑：</p>
<ol>
<li>如果 <code>prevLog</code> 不匹配，则返回 <code>Success = False</code></li>
<li>如果 <code>prevLog</code> 匹配，则将参数中的 <code>Entries</code> 追加到本地日志，返回 <code>Success = True</code>。</li>
</ol>
<p>所谓日志匹配：就是<strong>相同 Index 的地方，Term 相同</strong>；即 index 和 term 能唯一确定一条日志，这是因为，Raft 算法保证一个 Term 中最多有（也可能没有）一个 Leader，然后只有该 Leader 能确定日志顺序且同步日志。这样一来，Term 单调递增，每个 Term 只有一个 Leader，则该 Leader 能唯一确定该 Term 内的日志顺序。</p>
<p>此外，之前<strong>纯心跳逻辑</strong>（心跳逻辑和日志复制逻辑共用一个 RPC）只负责压制其他 Peer 发起选举，因此不用给 reply 返回信息。但此时，就需要用到 reply 了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">		<span class="comment">// other code...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// For debug</span></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;&lt;- S%d, Receive log, Prev=[%d]T%d, Len()=%d&quot;</span>, args.LeaderId, args.PrevLogIndex, args.PrevLogTerm, <span class="built_in">len</span>(args.Entries))</span><br><span class="line">        <span class="comment">// replay initialized</span></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// other code...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// return failure if the previous log not matched</span></span><br><span class="line">        <span class="keyword">if</span> args.PrevLogIndex &gt;= <span class="built_in">len</span>(rf.log) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;&lt;- S%d, Reject Log, Follower log too short, Len:%d &lt;= Prev:%d&quot;</span>, args.LeaderId, <span class="built_in">len</span>(rf.log), args.PrevLogIndex)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;&lt;- S%d, Reject Log, Prev log not match, [%d]: T%d != T%d&quot;</span>, args.LeaderId, args.PrevLogIndex, rf.log[args.PrevLogIndex].Term, args.PrevLogTerm)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// append the leader logs to local</span></span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log[:args.PrevLogIndex+<span class="number">1</span>], args.Entries...)</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;Follower append logs: (%d, %d]&quot;</span>, args.PrevLogIndex, args.PrevLogIndex+<span class="built_in">len</span>(args.Entries))</span><br><span class="line">        reply.Success = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// other code..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RPC-发送方"><a href="#RPC-发送方" class="headerlink" title="RPC 发送方"></a>RPC 发送方</h3><p>对于日志复制 RPC 发送方来说，需要增加两部分逻辑：</p>
<ol>
<li>每个 RPC 发送前的参数构造</li>
<li>每个 RPC 收到返回值后：<ol>
<li>如果复制成功，则看看是否可以更新 Leader 的 commitIndex （也留到之后实现，TODO，补充小节链接）</li>
<li>如果复制失败，则需要将匹配点回退，继续试探。</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startReplication(term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">				<span class="comment">// other code...</span></span><br><span class="line">            </span><br><span class="line">                <span class="comment">// probe the lower index if the prev log not matched</span></span><br><span class="line">                <span class="keyword">if</span> !reply.Success &#123;</span><br><span class="line">                        idx := rf.nextIndex[peer] - <span class="number">1</span></span><br><span class="line">                        term := rf.log[idx].Term</span><br><span class="line">                        <span class="keyword">for</span> idx &gt; <span class="number">0</span> &amp;&amp; rf.log[idx].Term == term &#123;</span><br><span class="line">                                idx--</span><br><span class="line">                        &#125;</span><br><span class="line">                        rf.nextIndex[peer] = idx + <span class="number">1</span></span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;Log not matched in %d, Update next=%d&quot;</span>, args.PrevLogIndex, rf.nextIndex[peer])</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// update the match/next index if log appended successfully</span></span><br><span class="line">                rf.matchIndex[peer] = args.PrevLogIndex + <span class="built_in">len</span>(args.Entries)</span><br><span class="line">                rf.nextIndex[peer] = rf.matchIndex[peer] + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> need compute the new commitIndex here, </span></span><br><span class="line">                <span class="comment">// but we leave it to the other chapter</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// other code ..</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                <span class="keyword">if</span> peer == rf.me &#123;</span><br><span class="line">                        <span class="comment">// Don&#x27;t forget to update Leader&#x27;s matchIndex</span></span><br><span class="line">                        rf.matchIndex[peer] = <span class="built_in">len</span>(rf.log) - <span class="number">1</span></span><br><span class="line">                        rf.nextIndex[peer] = <span class="built_in">len</span>(rf.log)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                prevIdx := rf.nextIndex[peer] - <span class="number">1</span></span><br><span class="line">                prevTerm := rf.log[prevIdx].Term</span><br><span class="line">                args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">                        Term:         rf.currentTerm,</span><br><span class="line">                        LeaderId:     rf.me,</span><br><span class="line">                        PrevLogIndex: prevIdx,</span><br><span class="line">                        PrevLogTerm:  prevTerm,</span><br><span class="line">                        Entries:      rf.log[prevIdx+<span class="number">1</span>:],</span><br><span class="line">                        LeaderCommit: rf.commitIndex,</span><br><span class="line">                &#125;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;-&gt; S%d, Send log, Prev=[%d]T%d, Len()=%d&quot;</span>, peer, args.PrevLogIndex, args.PrevLogTerm, <span class="built_in">len</span>(args.Entries))</span><br><span class="line">                <span class="keyword">go</span> replicateToPeer(peer, args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分的最终目的，就是要更新 <code>matchIndex</code>。进而依据所有 Peer 的 <code>matchIndex</code> 来算 <code>commitIndex</code> 。Leader 有了 <code>commitIndex</code> 之后，再将其下发给各个 Follower，指导其各自更新本地 <code>commitIndex</code> 进而 apply。</p>
<p><code>matchIndex</code> 和 <code>nextIndex</code>  是什么时候初始化的？所以，我们要继续补上这两个字段的初始化逻辑。本质上来说，这两个字段是各个 Peer 中日志进度在 Leader 中的一个<strong>视图</strong>（view）。Leader 正是依据此视图来决定给各个 Peer 发送多少日志。也是依据此视图，Leader 可以计算全局的 <code>commitIndex</code>。</p>
<p>因此，该视图只在 Leader 当选的 Term 中有用。故而，我们要在 Leader 一当选时，更新该视图，即 <code>becomeLeaderLocked</code> 中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeLeaderLocked() &#123;</span><br><span class="line">		<span class="comment">// other code...</span></span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                rf.nextIndex[peer] = <span class="built_in">len</span>(rf.log)</span><br><span class="line">                rf.matchIndex[peer] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选举日志比较"><a href="#选举日志比较" class="headerlink" title="选举日志比较"></a>选举日志比较</h2><h3 id="日志新旧比较"><a href="#日志新旧比较" class="headerlink" title="日志新旧比较"></a>日志新旧比较</h3><p> 比较对象是最后一个 LogEntry，<strong>比较规则</strong>是：</p>
<ol>
<li>Term 高者更新</li>
<li>Term 同，Index 大者更新</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> isMoreUpToDateLocked(candidateIndex, candidateTerm <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        l := <span class="built_in">len</span>(rf.log)</span><br><span class="line">        lastTerm, lastIndex := rf.log[l<span class="number">-1</span>].Term, l<span class="number">-1</span></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;Compare last log, Me: [%d]T%d, Candidate: [%d]T%d&quot;</span>, lastIndex, lastTerm, candidateIndex, candidateTerm)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> lastTerm != candidateTerm &#123;</span><br><span class="line">                <span class="keyword">return</span> lastTerm &gt; candidateTerm</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastIndex &gt; candidateIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增加日志比较"><a href="#增加日志比较" class="headerlink" title="增加日志比较"></a>增加日志比较</h3><p>选举这一块需要增加的逻辑比较简单，只需要：</p>
<ol>
<li>在发送 RPC 构造参数时增加上最后一条日志信息</li>
<li>在接收 RPC 投票前比较日志新旧</li>
</ol>
<p>根据论文图 2 补全 RPC 相关结构体字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RequestVoteArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// Your data here (PartA, PartB).</span></span><br><span class="line">        Term         <span class="type">int</span></span><br><span class="line">        CandidateId  <span class="type">int</span></span><br><span class="line">        LastLogIndex <span class="type">int</span></span><br><span class="line">        LastLogTerm  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送方（Candidate），在发送 RPC 增加构造参数，带上 Candidate 最后一条日志的信息（index 和 term）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startElection(term <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        l := <span class="built_in">len</span>(rf.log)</span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line">                args := &amp;RequestVoteArgs&#123;</span><br><span class="line">						<span class="comment">// ...</span></span><br><span class="line">                        LastLogIndex: l<span class="number">-1</span>,</span><br><span class="line">                        LastLogTerm:  rf.log[l<span class="number">-1</span>].Term,</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">go</span> askVoteFromPeer(peer, args)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收方（各个 Peer 的回调函数），在对齐 Term，检查完没有投过票之后，进一步比较最后一条日志，看谁的更新。如果本 Peer 比 Candidate 更新，则拒绝投票给 Candidate。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example RequestVote RPC handler.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// check log, only grante vote when the candidates have more up-to-date log</span></span><br><span class="line">        <span class="keyword">if</span> rf.isMoreUpToDateLocked(args.LastLogIndex，args.LastLogTerm) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;-&gt; S%d, Reject Vote, S%d&#x27;s log less up-to-date&quot;</span>, args.CandidateId)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="日志应用"><a href="#日志应用" class="headerlink" title="日志应用"></a>日志应用</h2><p>我们需要给 apply 逻辑补上两个字段：</p>
<ol>
<li><strong>commitIndex</strong>：全局日志提交进度</li>
<li><strong>lastApplied</strong>：本 Peer 日志 apply 进度</li>
</ol>
<p>由于我们想在实现时，使用 <code>sync.Cond</code> 唤醒 apply 的工作流，因此需要增加：**<code>applyCond</code>**。</p>
<p>最后，在我们 Raft 实现的设定中，apply 的过程，就是将 applyMsg 通过构造 Peer 时传进来的 channel 返回给应用层。因此还需要保存下这个 <strong>applyCh</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Go object implementing a single Raft peer.</span></span><br><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// commit index and last applied</span></span><br><span class="line">        commitIndex <span class="type">int</span></span><br><span class="line">        lastApplied <span class="type">int</span></span><br><span class="line">        applyCond   *sync.Cond</span><br><span class="line">        applyCh     <span class="keyword">chan</span> ApplyMsg</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加其初始化。<strong>applyCond</strong> 在初始化时，需要关联到一把锁上，这是<code> sync.Cond</code> 的使用要求，之后只有在该锁临界区内才可以进行 <code>Wait()</code> 和 <code>Signal()</code> 的调用。对于我们来说，这把锁自然就是全局的那把大锁：<code>rf.mu</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span></span> *Raft &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        </span><br><span class="line">        rf.applyCh = applyCh</span><br><span class="line">        rf.commitIndex = <span class="number">0</span></span><br><span class="line">        rf.lastApplied = <span class="number">0</span></span><br><span class="line">        rf.applyCond = sync.NewCond(&amp;rf.mu)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    	<span class="keyword">go</span> rf.applyTicker()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Apply-工作流"><a href="#Apply-工作流" class="headerlink" title="Apply 工作流"></a>Apply 工作流</h3><p>Apply 工作流在实现的时候，最重要的就是在给 applyCh 发送 ApplyMsg 时，不要在加锁的情况下进行。因为我们并不知道这个操作会耗时多久（即应用层多久会取走数据），因此不能让其在 apply 的时候持有锁。</p>
<p>于是，我们把 apply 分为三个阶段：</p>
<ol>
<li><strong>阶段一</strong>：构造所有待 apply 的 <code>ApplyMsg</code></li>
<li><strong>阶段二</strong>：遍历这些 msgs，进行 apply</li>
<li><strong>阶段三</strong>：更新 <code>lastApplied</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> applyTicker() &#123;</span><br><span class="line">        <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                rf.applyCond.Wait()</span><br><span class="line">				</span><br><span class="line">                entries := <span class="built_in">make</span>([]LogEntry, <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// should start from rf.lastApplied+1 instead of rf.lastApplied</span></span><br><span class="line">                <span class="keyword">for</span> i := rf.lastApplied + <span class="number">1</span>; i &lt;= rf.commitIndex; i++ &#123;</span><br><span class="line">                        entries = <span class="built_in">append</span>(entries, rf.log[i])</span><br><span class="line">                &#125;</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> i, entry := <span class="keyword">range</span> entries &#123;</span><br><span class="line">                        rf.applyCh &lt;- ApplyMsg&#123;</span><br><span class="line">                                CommandValid: entry.CommandValid,</span><br><span class="line">                                Command:      entry.Command,</span><br><span class="line">                                CommandIndex: rf.lastApplied + <span class="number">1</span> + i,</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DApply, <span class="string">&quot;Apply log for [%d, %d]&quot;</span>, rf.lastApplied+<span class="number">1</span>, rf.lastApplied+<span class="built_in">len</span>(entries))</span><br><span class="line">                rf.lastApplied += <span class="built_in">len</span>(entries)</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要我们保证全局就只有这一个 apply 的地方，那我们这样分成三个部分问题就不大。尤其是需要注意，当后面增加  snapshot  apply 的逻辑时，也要放到该函数里。</p>
<h3 id="Leader-CommitIndex-更新"><a href="#Leader-CommitIndex-更新" class="headerlink" title="Leader CommitIndex 更新"></a>Leader CommitIndex 更新</h3><p>在 Leader 给其他 Peer <code>AppendEntries</code> 成功后，会更新 <code>rf.matchIndex</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        majorityMatched := rf.getMajorityIndexLocked()</span><br><span class="line">        <span class="keyword">if</span> majorityMatched &gt; rf.commitIndex &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DApply, <span class="string">&quot;Leader update the commit index %d-&gt;%d&quot;</span>, rf.commitIndex, majorityMatched)</span><br><span class="line">                rf.commitIndex = majorityMatched</span><br><span class="line">                rf.applyCond.Signal()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每次更新 <code>rf.matchIndex</code> 后，依据此全局匹配点视图，我们可以算出多数 Peer 的匹配点，进而更新 Leader 的 <code>CommitIndex</code>。我们可以使用<strong>排序后找中位数</strong>的方法来计算。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> getMajorityIndexLocked() <span class="type">int</span> &#123;</span><br><span class="line">        <span class="comment">// TODO(spw): may could be avoid copying</span></span><br><span class="line">        tmpIndexes := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(rf.matchIndex))</span><br><span class="line">        <span class="built_in">copy</span>(tmpIndexes, rf.matchIndex)</span><br><span class="line">        sort.Ints(sort.IntSlice(tmpIndexes))</span><br><span class="line">        majorityIdx := (<span class="built_in">len</span>(tmpIndexes) - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;Match index after sort: %v, majority[%d]=%d&quot;</span>, tmpIndexes, majorityIdx, tmpIndexes[majorityIdx])</span><br><span class="line">        <span class="keyword">return</span> tmpIndexes[majorityIdx] <span class="comment">// min -&gt; max</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于排序会改变原数组，因此要把 matchIndex 复制一份再进行排序，</p>
<p><strong>如果 <code>commitIndex</code> 更新后，则唤醒 apply 工作流，提醒可以 apply 新的日志到本地了。</strong></p>
<h3 id="Follower-CommitIndex-更新"><a href="#Follower-CommitIndex-更新" class="headerlink" title="Follower CommitIndex 更新"></a>Follower CommitIndex 更新</h3><p>在 Leader CommitIndex 更新后，会通过下一次的 <code>AppendEntries</code> 的 RPC 参数发送给每个 Follower。则首先，要根据论文图 2，在 <code>AppendEntriesArgs</code> 中增加 <code>LeaderCommit</code> 参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">        Term     <span class="type">int</span></span><br><span class="line">        LeaderId <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        PrevLogIndex <span class="type">int</span></span><br><span class="line">        PrevLogTerm  <span class="type">int</span></span><br><span class="line">        Entries      []LogEntry</span><br><span class="line"></span><br><span class="line">        LeaderCommit <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 Follower 通过 AppendEntries 的回调函数收到 Leader 发来的 <code>LeaderCommit</code>，来更新本地的 <code>CommitIndex</code>，进而驱动 Apply 工作流开始干活。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// update the commit index if needed and indicate the apply loop to apply</span></span><br><span class="line">        <span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DApply, <span class="string">&quot;Follower update the commit index %d-&gt;%d&quot;</span>, rf.commitIndex, args.LeaderCommit)</span><br><span class="line">                rf.commitIndex = args.LeaderCommit</span><br><span class="line">                <span class="keyword">if</span> rf.commitIndex &gt;= <span class="built_in">len</span>(rf.log) &#123;</span><br><span class="line">                    rf.commitIndex = <span class="built_in">len</span>(rf.log) - <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                rf.applyCond.Signal()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面 Peer 收到 Leader 发来的日志同步请求处理逻辑中，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.Term &gt;= rf.currentTerm &#123;</span><br><span class="line">            rf.becomeFollowerLocked(args.Term)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于大于的情况，容易理解，论文中就这么写的。为什么相同任期也要变为 Follower？</p>
<p>对于相同任期来说，可以分情况考虑：</p>
<ol>
<li>首先他不可能是 leader，因为一个任期最多只会选出一个 leader</li>
<li>如果他是 Candidate，收到 Leader 的日志同步请求，得变 Follower</li>
<li>如果本来就是 Follower 就无所谓了</li>
</ol>
<h2 id="实现要点-1"><a href="#实现要点-1" class="headerlink" title="实现要点"></a>实现要点</h2><h3 id="Context-检查"><a href="#Context-检查" class="headerlink" title="Context 检查"></a>Context 检查</h3><p>需要 Context 检查的主要有四个地方：</p>
<ol>
<li>startReplication 前，检查自己仍然是给定 term 的 Leader</li>
<li>replicateToPeer 处理 reply 时，检查自己仍然是给定 term 的 Leader</li>
<li>startElection 前，检查自己仍然是给定 term 的 Candidate</li>
<li>askVoteFromPeer 处理 reply 时，检查自己仍然是给定 term 的 Candidate</li>
</ol>
<p>由于我们 replication 和 election 实现的对称性，可以发现前两个和后两个是对称的，因此很好记忆。</p>
<h3 id="Start-实现"><a href="#Start-实现" class="headerlink" title="Start 实现"></a>Start 实现</h3><p>只有正确实现了 Start，tester 才能通过 Start 给 Leader 本地追加日志。进而通过 Leader 的 AppendEntries RPC 将日志分发给所有 Follower，然后在发现大多数 Peer 在本地追加该日志之后，指示每个 Peer Apply 该日志。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Start(command <span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rf.role != Leader &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log, LogEntry&#123;</span><br><span class="line">                CommandValid: <span class="literal">true</span>,</span><br><span class="line">                Command:      command,</span><br><span class="line">                Term:         rf.currentTerm,</span><br><span class="line">        &#125;)</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DLeader, <span class="string">&quot;Leader accept log [%d]T%d&quot;</span>, <span class="built_in">len</span>(rf.log)<span class="number">-1</span>, rf.currentTerm)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(rf.log) - <span class="number">1</span>, rf.currentTerm, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试时遇到的小问题，<code>/usr/bin/env: ‘python3\r’: No such file or directory</code> ，这是由于换行符导致的，解决方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dos2unix ../tools/dstest</span><br></pre></td></tr></table></figure>

<h1 id="PartC-持久化"><a href="#PartC-持久化" class="headerlink" title="PartC 持久化"></a>PartC 持久化</h1><h2 id="逻辑实现"><a href="#逻辑实现" class="headerlink" title="逻辑实现"></a>逻辑实现</h2><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// raft_persistence.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> persistLocked() &#123;</span><br><span class="line">    <span class="comment">// Your code here (PartC).</span></span><br><span class="line">    <span class="comment">// Example:</span></span><br><span class="line">    w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    e := labgob.NewEncoder(w)</span><br><span class="line">    e.Encode(rf.currentTerm)</span><br><span class="line">    e.Encode(rf.votedFor)</span><br><span class="line">    e.Encode(rf.log)</span><br><span class="line">    raftstate := w.Bytes()</span><br><span class="line">    rf.persister.Save(raftstate, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// restore previously persisted state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> readPersist(data []<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> data == <span class="literal">nil</span> || <span class="built_in">len</span>(data) &lt; <span class="number">1</span> &#123; <span class="comment">// bootstrap without any state?</span></span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Your code here (PartC).</span></span><br><span class="line">    <span class="comment">// Example:</span></span><br><span class="line">    r := bytes.NewBuffer(data)</span><br><span class="line">    d := labgob.NewDecoder(r)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentTerm <span class="type">int</span></span><br><span class="line">    <span class="keyword">if</span> err := d.Decode(&amp;currentTerm); err != <span class="literal">nil</span> &#123;</span><br><span class="line">       LOG(rf.me, rf.currentTerm, DPersist, <span class="string">&quot;Read currentTerm error: %v&quot;</span>, err)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    rf.currentTerm = currentTerm</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> votedFor <span class="type">int</span></span><br><span class="line">    <span class="keyword">if</span> err := d.Decode(&amp;votedFor); err != <span class="literal">nil</span> &#123;</span><br><span class="line">       LOG(rf.me, rf.currentTerm, DPersist, <span class="string">&quot;Read votedFor error: %v&quot;</span>, err)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    rf.votedFor = votedFor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> log []LogEntry</span><br><span class="line">    <span class="keyword">if</span> err := d.Decode(&amp;log); err != <span class="literal">nil</span> &#123;</span><br><span class="line">       LOG(rf.me, rf.currentTerm, DPersist, <span class="string">&quot;Read log error: %v&quot;</span>, err)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    rf.log = log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 图2 可知，在  Raft 结构体中，需要持久化的主要有三个字段：<code>currentTerm</code>， <code>votedFor</code> ， <code>log</code> 。这三者需要持久化的原因：</p>
<p><img src="https://www.freeimg.cn/i/2024/02/07/65c319fa416b4.png"></p>
<ol>
<li><code>currentTerm</code> ：重启之后一定要知道自己之前任期到了哪里，因为任期是状态机中一切正确行为的基础。</li>
<li><code>votedFor</code> ：如果在某个任期已经投过票了，重启之后显然不能重复投票。</li>
<li><code>log</code> ：日志自然需要持久化，否则集群内的多数机器重启多次，已提交的日志就会丢失。</li>
</ol>
<p>其次，由于上述的三个字段均为全局变量，因此需要在临界区调用，不然会出现数据竟态（data race）。故需要加上 <code>-Locked</code> 后缀。</p>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><h4 id="readPersist"><a href="#readPersist" class="headerlink" title="readPersist"></a>readPersist</h4><p><code>readPersist</code> 函数只有在重启加载时才需要调用，也就是在构造 Raft 实例时。但需要注意的是，一定要在所有字段初始化完成后，再调用该函数。</p>
<p>如果是先调用 <code>readPersist</code> 再去初始化，就会把 <code>readPersist</code> 读出来的值给覆盖掉。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span></span> *Raft &#123;</span><br><span class="line">        rf := &amp;Raft&#123;&#125;</span><br><span class="line">        rf.peers = peers</span><br><span class="line">        rf.persister = persister</span><br><span class="line">        rf.me = me</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  initialization code </span></span><br><span class="line">        rf.role = Follower</span><br><span class="line">        rf.currentTerm = <span class="number">1</span> <span class="comment">// leave 0 to invalid</span></span><br><span class="line">        rf.votedFor = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// a dummy entry to aovid lots of corner checks</span></span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log, LogEntry&#123;Term: InvalidTerm&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize the leader&#x27;s view slice</span></span><br><span class="line">        rf.nextIndex = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(rf.peers))</span><br><span class="line">        rf.matchIndex = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(rf.peers))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize the fields used for apply</span></span><br><span class="line">        rf.applyCh = applyCh</span><br><span class="line">        rf.applyCond = sync.NewCond(&amp;rf.mu)</span><br><span class="line">        rf.commitIndex = <span class="number">0</span></span><br><span class="line">        rf.lastApplied = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize from state persisted before a crash</span></span><br><span class="line">        rf.readPersist(persister.ReadRaftState())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// start election ticker and apply ticker</span></span><br><span class="line">        <span class="keyword">go</span> rf.electionTicker()</span><br><span class="line">        <span class="keyword">go</span> rf.applicationTicker()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="persistLocked"><a href="#persistLocked" class="headerlink" title="persistLocked"></a>persistLocked</h4><p><code>persistLocked</code> 函数在上述三个字段被改变时需要调用。</p>
<p>在 <code>raft.go </code> 中有三处：</p>
<p>在 Leader 接受应用层命令的接口 <code>Start</code> 函数中，要将 <code>command</code> 包裹为日志，然后追加到本地日志中，即会修改 <code>rf.log </code>，因此要调用 <code>persist</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Start(command <span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rf.role != Leader &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log, LogEntry&#123;</span><br><span class="line">                CommandValid: <span class="literal">true</span>,</span><br><span class="line">                Command:      command,</span><br><span class="line">                Term:         rf.currentTerm,</span><br><span class="line">        &#125;)</span><br><span class="line">        rf.persistLocked()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(rf.log) - <span class="number">1</span>, rf.currentTerm, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在状态机相关函数中，<code>becomeFollower</code> 和 <code>becomeCandidate</code> 都有可能会涉及 <code>term</code> 和 <code>votedFor</code> 的更新，因此要加：</p>
<ol>
<li><code>becomeFollower</code>：注意该函数中，term 是有可能不变的。在 term 不变时，并不需要 <code>persist</code>——因为 term 不变，<code>votedFor</code> 一定不会被重新赋值。</li>
<li><code>becomeCandidate</code>：变 Candidate，一定会自增 term，同时投自己的票。因此肯需要调用 <code>persist</code>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeFollowerLocked(term <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> term &lt; rf.currentTerm &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.role = Follower</span><br><span class="line"></span><br><span class="line">        shouldPersist := term != rf.currentTerm</span><br><span class="line">        <span class="keyword">if</span> term &gt; rf.currentTerm &#123;</span><br><span class="line">                rf.votedFor = <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.currentTerm = term</span><br><span class="line">        <span class="keyword">if</span> shouldPersist &#123;</span><br><span class="line">                rf.persistLocked()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeCandidateLocked() &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.role == Leader &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rf.currentTerm++</span><br><span class="line">        rf.role = Candidate</span><br><span class="line">        rf.votedFor = rf.me</span><br><span class="line">        rf.persistLocked()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>raft_election.go</code> 中一处：</p>
<p>在要票的回调函数 <code>RequestVote</code> 中，如果 Peer 投出票，则会修改 <code>votedFor</code>，因此需要调用 <code>persist</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">        <span class="comment">// Your code here (PartA, PartB).</span></span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="comment">// ...... some code omitted</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// check for votedFor</span></span><br><span class="line">        <span class="comment">// ...... some code omitted</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// check if candidate&#x27;s last log is more up to date</span></span><br><span class="line">        <span class="keyword">if</span> rf.isMoreUpToDateLocked(args.LastLogIndex, args.LastLogTerm) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">        rf.votedFor = args.CandidateId</span><br><span class="line">        rf.persistLocked()</span><br><span class="line">        rf.resetElectionTimerLocked()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>raft_replication.go</code> 有一处：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="comment">// ...... some code omitted</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// will be explained in the next section</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                rf.resetElectionTimerLocked()</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return failure if prevLog not matched</span></span><br><span class="line">        <span class="keyword">if</span> args.PrevLogIndex &gt;= <span class="built_in">len</span>(rf.log) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// append the leader log entries to local</span></span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log[:args.PrevLogIndex+<span class="number">1</span>], args.Entries...)</span><br><span class="line">        rf.persistLocked()</span><br><span class="line">        reply.Success = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// hanle LeaderCommit</span></span><br><span class="line">        <span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">                rf.commitIndex = args.LeaderCommit</span><br><span class="line">                rf.applyCond.Signal()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="日志回溯优化"><a href="#日志回溯优化" class="headerlink" title="日志回溯优化"></a>日志回溯优化</h3><p>由于 <code>Leader</code> 在向 <code>Follower</code> 同步日志时，采用的是 <strong>乐观+回撤</strong> 的做法，而每次回撤后都需要下一个 RPC 才能发给 Follower，而我们的 <code>AppendEntries</code> RPC 是周期性的，每次回撤都需等待一个 <code>replicationInterval</code>。</p>
<p>在 Leader <strong>只基于自己的日志</strong> 进行回撤的情况下，回退一个 Index 或者一个 Term 的速度都太慢了。</p>
<p>考虑让 Follower 给一些辅助信息——告诉 Leader 自己日志大概处理到的位置</p>
<p>给 AppendEntriesReply 增加两个字段，以携带一些 Follower 和 Leader 的冲突信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// Your data here (PartA).</span></span><br><span class="line">        Term    <span class="type">int</span></span><br><span class="line">        Success <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">        ConflictIndex <span class="type">int</span></span><br><span class="line">        ConflictTerm  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Follower 端流程如下：</p>
<ol>
<li>如果 Follwer 日志过短，则 <code>ConflictTerm</code> 置空，<code>ConflictIndex = len(rf.log)</code>。</li>
<li>否则，将 <code>ConflictTerm</code> 设置为 Follower 在 <code>Leader.PrevLogIndex</code> 处的 term；<code>ConflictIndex</code> 设置为 <code>ConflictTerm</code> 的第一条日志。</li>
</ol>
<p>做法一的好处：如果 Follower 过短，提示 Leader 直接回到 Follower 日志的末尾，而不需要一个一个的试探。</p>
<p>做法二的好处：如果 Follower 存在 <code>Leader.PrevLog</code>，但是不匹配，那就应该跳过这个 term 的所有日志。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- rf.AppendEntries in raft_replication.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// return failure if prevLog not matched</span></span><br><span class="line"><span class="keyword">if</span> args.PrevLogIndex &gt;= <span class="built_in">len</span>(rf.log) &#123;</span><br><span class="line">        reply.ConfilictIndex = <span class="built_in">len</span>(rf.log)</span><br><span class="line">        reply.ConfilictTerm = InvalidTerm</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line">        reply.ConfilictTerm = rf.log[args.PrevLogIndex].Term</span><br><span class="line">        reply.ConfilictIndex = rf.firstLogFor(reply.ConfilictTerm)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Leader 端流程如下：</p>
<ol>
<li>如果 <code>ConflictTerm</code>  为空，说明 Follower 日志过短，直接将 <code>rf.nextIndex[peer]</code> 赋值为 <code>ConflictIndex</code> 迅速回退到 Follower 日志末端。</li>
<li>否则，以 Leader 为准，跳过 <code>ConflictTerm</code> 的所有日志，如果发现 Leader 中日志不存在 <code>ConflictTerm</code> 的任何日志，则以 Follower 为准跳过 <code>ConflictTerm</code> ，即使用 <code>ConflictIndex</code>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !reply.Success &#123;</span><br><span class="line">        prevNext := rf.nextIndex[peer]</span><br><span class="line">        <span class="keyword">if</span> reply.ConflictTerm == InvalidTerm &#123;</span><br><span class="line">        		rf.nextIndex[peer] = reply.ConflictIndex	</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		firstTermIndex := rf.firstLogFor(reply.ConflictTerm)</span><br><span class="line">           		<span class="keyword">if</span> firstTermIndex != InvalidIndex &#123;</span><br><span class="line">              			rf.nextIndex[peer] = firstTermIndex + <span class="number">1</span></span><br><span class="line">        		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              			rf.nextIndex[peer] = reply.ConflictIndex</span><br><span class="line">           		&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> prevNext &lt; rf.nextIndex[peer] &#123;</span><br><span class="line">           		rf.nextIndex[peer] = prevNext</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于我们如何表示空 term 和空 index 呢？</p>
<ol>
<li><strong>空 term</strong>：可以在 make Raft 时让 term 从 1 开始，则 0 就空了出来，可以用来表示空 term，在代码里叫 <code>InvalidTerm</code></li>
<li><strong>空 index</strong>：还记得我们在 rf.log 起始加了一个空 entry 吗？由于这个小技巧，我们的有效日志也是永远从 1 开始，0 就可以用来标识空 index，代码中叫 <code>InvalidIndex</code> 。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- in raft.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        InvalidIndex <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">        InvalidTerm  <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>为了让代码看着更易懂，我们封装了一个在日志数组中找指定 term 第一条日志的函数<code>rf.firstLogFor</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- in raft.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> firstLogFor(term <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i, entry := <span class="keyword">range</span> rf.log &#123;</span><br><span class="line">                <span class="keyword">if</span> entry.Term == term &#123;</span><br><span class="line">                        <span class="keyword">return</span> i</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> entry.Term &gt; term &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> InvalidIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于日志的 Term 是一段段的单调递增，则从前往后找到的第一个 term 的日志就是我们要找的位置，如果相关的 term 不存在，直接返回 <code>InvalidIndex</code> 。</p>
<h2 id="Bug-修复"><a href="#Bug-修复" class="headerlink" title="Bug 修复"></a>Bug 修复</h2><p>在收到 AppendEntries RPC 时，无论 Follower 接受还是拒绝日志，只要认可对方是 Leader 就要<strong>重置时钟</strong>。但在我们之前的实现，只有接受日志才会重置时钟。这是不对的，如果 Leader 和 Follower 匹配日志所花时间特别长，Follower 一直不重置选举时钟，就有可能错误的选举超时触发选举。</p>
<p>这里我们可以用一个 defer 函数来在合适位置之后来无论如何都要重置时钟：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- in raft_replication.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="comment">// ...... some code omitted</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// After we align the term, we accept the args.LeaderId as</span></span><br><span class="line">        <span class="comment">// Leader, then we must reset election timer wheter we</span></span><br><span class="line">        <span class="comment">// accept the log or not</span></span><br><span class="line">        <span class="keyword">defer</span> rf.resetElectionTimerLocked()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// return failure if prevLog not matched</span></span><br><span class="line">        <span class="keyword">if</span> args.PrevLogIndex &gt;= <span class="built_in">len</span>(rf.log) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line">                <span class="comment">// if we truncate log here, should persist</span></span><br><span class="line">                rf.log = rf.log[<span class="number">0</span>:args.PrevLogIndex] </span><br><span class="line">                rf.persistLocked()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// append the leader log entries to local</span></span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log[:args.PrevLogIndex+<span class="number">1</span>], args.Entries...)</span><br><span class="line">        rf.persistLocked()</span><br><span class="line">        reply.Success = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// hanle LeaderCommit</span></span><br><span class="line">        <span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">                rf.commitIndex = args.LeaderCommit</span><br><span class="line">                rf.applyCond.Signal()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其二，匹配探测期比较长时，会有多个探测的 RPC，如果 RPC 结果乱序回来：一个先发出去的探测 RPC 后回来了，其中所携带的 <code>ConfilictTerm</code> 和 <code>ConfilictIndex</code> 就有可能造成 <code>rf.next</code> 的“反复横跳”。为此，我们可以强制 <code>rf.next</code> 单调递减：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- rf.startReplication in raft_replication.go</span></span><br><span class="line"><span class="keyword">if</span> !reply.Success &#123;</span><br><span class="line">        prevIndex := rf.nextIndex[peer]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// some code omitted....</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// avoid the late reply move the nextIndex forward again</span></span><br><span class="line">        <span class="keyword">if</span> rf.nextIndex[peer] &gt; prevIndex &#123;</span><br><span class="line">                rf.nextIndex[peer] = prevIndex</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其三，Leader 只能提交本 Term 的日志，在 <code>raft_replication.go</code> 中，将更新 <code>commitIndex</code> 的条件进行修改：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startReplication(term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">                reply := &amp;AppendEntriesReply&#123;&#125;</span><br><span class="line">                ok := rf.sendAppendEntries(peer, args, reply)</span><br><span class="line"></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ...... some code ommited</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// update match/next index if log appended successfully</span></span><br><span class="line">                rf.matchIndex[peer] = args.PrevLogIndex + <span class="built_in">len</span>(args.Entries) <span class="comment">// important</span></span><br><span class="line">                rf.nextIndex[peer] = rf.matchIndex[peer] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// update the commitIndex</span></span><br><span class="line">                majorityMatched := rf.getMajorityIndexLocked()</span><br><span class="line">                <span class="keyword">if</span> majorityMatched &gt; rf.commitIndex &amp;&amp; rf.log[majorityMatched].Term == rf.currentTerm &#123;</span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DApply, <span class="string">&quot;Leader update the commit index %d-&gt;%d&quot;</span>, rf.commitIndex, majorityMatched)</span><br><span class="line">                        rf.commitIndex = majorityMatched</span><br><span class="line">                        rf.applyCond.Signal()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...... some code ommited</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="PartD-日志压缩"><a href="#PartD-日志压缩" class="headerlink" title="PartD 日志压缩"></a>PartD 日志压缩</h1><h2 id="实现要求"><a href="#实现要求" class="headerlink" title="实现要求"></a>实现要求</h2><p>对于一个长时间运行的 Raft 系统，如果持续收到日志，会遇到以下问题：</p>
<ol>
<li><strong>空间不够</strong>：如果日志无限追加下去，本地硬盘空间可能存不下。</li>
<li><strong>重启过慢</strong>：因为重启时需要重放（ replay）所有日志，如果日志过长，重放过程将会持续很久不能正常对外提供服务。</li>
</ol>
<p>一个经典的解决办法是，定期对日志做<strong>快照</strong>（snapshot）。针对某个日志 entry 做了快照之后，该 entry 以及以前的日志变都可以被<strong>截断</strong>（<strong>truncate</strong>）</p>
<p>但这样同时会引出另一个问题：如果 Leader 想给从节点发送日志时，发现相关日志条目已经被截断怎么办？这就需要引入一个新的 RPC：<code>InstallSnapshot</code>。通过此 RPC，先将 Leader 的 Snapshot 无脑同步给 Follower，再做之后日志同步。</p>
<p>最终，你的 Raft 实现需要对外提供以下接口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Snapshot(index int, snapshot []byte)</span><br></pre></td></tr></table></figure>

<p>在 PartD 的测试中，测试框架会定期调用该接口，其含义大致是：<strong>应用层</strong>表示我在 index 处做了一个 snapshot，<strong>raft 层</strong>可以记下该 snapshot，并且把 index 以及以前的日志给删掉了。</p>
<p>需要注意的是，测试框架会在每个 Peer （而非只在 Leader） 上，调用该接口。</p>
<p>我们重新梳理一遍你需要实现的内容：</p>
<ol>
<li>实现一个 <code>Snapshot()</code> 接口，承接应用层来的快照请求</li>
<li>实现一套 <code>InstallSnapshot </code> RPC，当日志同步时发现日志被截断时先同步 Snapshot</li>
</ol>
<p>在 1 中，你需要将应用层传下来的 snapshot 存储下来，以备 2 使用。此外，在 2 中，如果 Follower 接受到 snapshot 时，也需要将其存下来，以备<strong>重启</strong>或者将来变成 <strong>Leader 使用</strong>。在这两种情况下，你都可以使用 <code>persister.Save()</code> 来存。</p>
<p>在 Raft 因为宕机重启时，如果有 snapshot，那么第一步就是要先应用 snapshot。你可以往 <code>applyCh</code> 中发一个 <code>ApplyMsg</code> 来应用 snapshot。当然，此处的 <code>ApplyMsg</code> 要用上之前 lab 没有使用的其他字段了，就是下面代码中的 For PartD 部分：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ApplyMsg <span class="keyword">struct</span> &#123;</span><br><span class="line">        CommandValid <span class="type">bool</span></span><br><span class="line">        Command      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">        CommandIndex <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// For PartD:</span></span><br><span class="line">        SnapshotValid <span class="type">bool</span></span><br><span class="line">        Snapshot      []<span class="type">byte</span></span><br><span class="line">        SnapshotTerm  <span class="type">int</span></span><br><span class="line">        SnapshotIndex <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="日志重构"><a href="#日志重构" class="headerlink" title="日志重构"></a>日志重构</h2><p>要支持 Compaction，需要对日志进行诸多改造。干脆，我们将相关逻辑封装到一个 <code>struct</code> 中。</p>
<p>于是我们新创建一个 <code>RaftLog</code> 的结构体，以支持：</p>
<ol>
<li><strong>在 index 处进行 Snapshot</strong>：将 index 以及之前的日志截断掉</li>
<li>基本读写操作：<ol>
<li><strong>读取</strong>：在 Snapshot 存在时，需要做下标转换，但在没有 Snapshot 时又不用，需要想办法进行统一。</li>
<li><strong>追加</strong>：包括在末尾追加（用于应用层给 Leader 追加日志）、在给定下标处覆盖追加（用于 Leader 覆写 Follower 日志）等等。</li>
</ol>
</li>
</ol>
<h3 id="RaftLog-实现"><a href="#RaftLog-实现" class="headerlink" title="RaftLog 实现"></a>RaftLog 实现</h3><h4 id="结构体字段"><a href="#结构体字段" class="headerlink" title="结构体字段"></a>结构体字段</h4><p>我们新建一个文件，起名为 <code>raft_log.go </code>，然后定义一个 <code>RaftLog</code> 的结构体。主要包含三部分：</p>
<ol>
<li>前面日志截断后 compact 成的 <code>snapshot</code></li>
<li>后面的剩余日志 <code>tailLog</code></li>
<li>两者的<strong>分界线</strong>，也就是上一节要求中提到的：<code>lastIncludeTerm</code>&#x2F;<code>lastIncludeIndex</code>，这里我们给他加上 snap 前缀，可以更直观一些，知道是 snapshot 最后的下标和任期，即 <code>snapLastIdx</code> &#x2F; <code>snapLastTerm</code> 。</li>
</ol>
<p>这里有个巧妙的设计点，可以避免边界判断、一致化下标转换。即，将 <code>tailLog</code> 中下标为 0 （对应 <code>snapLastIdx</code>）的日志留空，但给其的 <code>Term</code> 字段赋值 <code>snapLastTerm</code>，真正的下标从 1 （对应 <code>snapLastIdx</code>+1）开始。</p>
<p>这样做有什么好处呢？更具体来说就是：</p>
<ol>
<li><strong>边界判断</strong>：在进行日志复制时，需要取所发送日志的 <code>prevLogIndex</code> 和 <code>prevLogTerm</code> 时，可以避免特殊判断。</li>
<li><strong>下标转换</strong>：所有的全局下标转到 <code>tailLog</code> 下标时，只需要减去 <code>snapLastIdx</code> 即可</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RaftLog <span class="keyword">struct</span> &#123;</span><br><span class="line">        snapLastIdx  <span class="type">int</span></span><br><span class="line">        snapLastTerm <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// contains index [1, snapLastIdx]</span></span><br><span class="line">        snapshot []<span class="type">byte</span></span><br><span class="line">        <span class="comment">// the first entry is `snapLastIdx`, but only contains the snapLastTerm</span></span><br><span class="line">        <span class="comment">// the entries between (snapLastIdx, snapLastIdx+len(tailLog)-1] have real data</span></span><br><span class="line">        tailLog []LogEntry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>换个角度理解，就是我们在 <code>tailLog</code> 的开始 mock 了一个假的 snapshot 的 <code>lastIncludeEntry</code>。且当 snapshot 为空时，该 <code>lastIncludeEntry</code> 的 index 和 term 都是 0 。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>对 RaftLog 初始化，有两条路径：</p>
<ol>
<li><strong>构造函数</strong>：在通过 Make 构造 Raft 实例时使用，此时各个字段留默认值就行。</li>
<li><strong>反序列化函数</strong>：读取宕机前（如果有）持久化的各个字段，对 <code>RaftLog</code> 进行填充。</li>
</ol>
<p>且通常，两个是在 Make 函数中先后执行，因此构造函数其实可以留空，但下面我们为了将来的可扩展性仍然实现了，仅在调用时传空。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// called as : rf.log = NewLog(InvalidIndex, InvalidTerm, nil, nil)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLog</span><span class="params">(snapLastIdx, snapLastTerm <span class="type">int</span>, snapshot []<span class="type">byte</span>, entries []LogEntry)</span></span> *RaftLog &#123;</span><br><span class="line">        rl := &amp;RaftLog&#123;</span><br><span class="line">                snapLastIdx:  snapLastIdx,</span><br><span class="line">                snapLastTerm: snapLastTerm,</span><br><span class="line">                snapshot:     snapshot,</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// make the len = 0, cap = 1 + len(entries)</span></span><br><span class="line">        rl.tailLog := <span class="built_in">make</span>([]LogEntry, <span class="number">0</span>, <span class="number">1</span> + <span class="built_in">len</span>(entries)) </span><br><span class="line">        rl.tailLog = <span class="built_in">append</span>(rl.tailLog, LogEntry&#123;</span><br><span class="line">                Term: snapLastTerm,</span><br><span class="line">        &#125;)</span><br><span class="line">        rl.tailLog = <span class="built_in">append</span>(rl.tailLog, entries...)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return detailed error for the caller to log</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> readPersist(d *labgob.LabDecoder) <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> lastIdx <span class="type">int</span></span><br><span class="line">        <span class="keyword">if</span> err := d.Decode(&amp;lastIdx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decode last include index failed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        rl.snapLastIdx = lastIdx</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> lastTerm <span class="type">int</span></span><br><span class="line">        <span class="keyword">if</span> err := d.Decode(&amp;lastTerm); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decode last include term failed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        rl.snapLastTerm = lastTerm</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> log []LogEntry</span><br><span class="line">        <span class="keyword">if</span> err := d.Decode(&amp;log); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decode tail log failed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        rl.tailLog = log</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> persist(e *labgob.LabEncoder) &#123;</span><br><span class="line">        e.Encode(rl.snapLastIdx)</span><br><span class="line">        e.Encode(rl.snapLastTerm)</span><br><span class="line">        e.Encode(rl.tailLog)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="下标操作"><a href="#下标操作" class="headerlink" title="下标操作"></a>下标操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the dummy log is counted</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> size() <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rl.snapLastIdx + <span class="built_in">len</span>(rl.tailLog)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// access the index `rl.snapLastIdx` is allowed, although it&#x27;s not exist actually.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> idx(logicIdx <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> logicIdx &lt; rl.snapLastIdx || logicIdx &gt;= rl.size() &#123;</span><br><span class="line">                <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%d is out of [%d, %d]&quot;</span>, logicIdx, rl.snapLastIdx+<span class="number">1</span>, rl.size()<span class="number">-1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> logicIdx - rl.snapLastIdx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> at(logicIdx <span class="type">int</span>) LogEntry &#123;</span><br><span class="line">        <span class="keyword">return</span> rl.tailLog[rl.idx(logicIdx)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> last() (idx, term <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rl.size() - <span class="number">1</span>, rl.tailLog[<span class="built_in">len</span>(rl.tailLog)<span class="number">-1</span>].Term</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> tail(startIdx <span class="type">int</span>) []LogEntry &#123;</span><br><span class="line">        <span class="keyword">if</span> startIdx &gt;= rl.size() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rl.tailLog[rl.idx(startIdx):]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> firstLogFor(term <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> idx, entry := <span class="keyword">range</span> rl.tailLog &#123;</span><br><span class="line">                <span class="keyword">if</span> entry.Term == term &#123;</span><br><span class="line">                        <span class="keyword">return</span> idx</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> entry.Term &gt; term &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> InvalidIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> <span class="built_in">append</span>(e LogEntry) &#123;</span><br><span class="line">        rl.tailLog = <span class="built_in">append</span>(rl.tailLog, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> appendFrom(prevIdx <span class="type">int</span>, entries []LogEntry) &#123;</span><br><span class="line">        rl.tailLog = <span class="built_in">append</span>(rl.tailLog[:rl.idx(prevIdx)+<span class="number">1</span>], entries...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Snapshot-基本实现"><a href="#Snapshot-基本实现" class="headerlink" title="Snapshot 基本实现"></a>Snapshot 基本实现</h3><p>该函数的基本含义为：应用层在 index 处做了个快照，Raft 层帮我把该快照保存下，同时，index 以及之前的日志就可以释放掉了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- raft.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the service says it has created a snapshot that has</span></span><br><span class="line"><span class="comment">// all info up to and including index. this means the</span></span><br><span class="line"><span class="comment">// service no longer needs the log through (and including)</span></span><br><span class="line"><span class="comment">// that index. Raft should now trim its log as much as possible.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Snapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line">        <span class="comment">// Your code here (PartD).</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DSnap, <span class="string">&quot;Snap on %d&quot;</span>, index)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index &lt;= rf.log.snapLastIdx || index &gt; rf.commitIndex &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DSnap, <span class="string">&quot;Could not snapshot beyond [%d, %d]&quot;</span>, rf.log.snapLastIdx+<span class="number">1</span>, rf.commitIndex)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rf.log.doSnapshot(index, snapshot)</span><br><span class="line">        rf.persistLocked()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进行日志截断的时候，注意要新建一个数组，而不要直接使用下标切片运算。只有新建数组并切换过去，才会真正的解掉对于原来数组的引用，保证 golang GC 可以将原来数组的空间释放掉。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- raft_log.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> doSnapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line">        <span class="comment">// since idx() will use rl.snapLastIdx, so we should keep it first</span></span><br><span class="line">        idx := rl.idx(index)</span><br><span class="line"></span><br><span class="line">        rl.snapLastTerm = rl.tailLog[idx].Term</span><br><span class="line">        rl.snapLastIdx = index</span><br><span class="line">        rl.snapshot = snapshot</span><br><span class="line"></span><br><span class="line">        <span class="comment">// allocate a new slice</span></span><br><span class="line">        newLog := <span class="built_in">make</span>([]LogEntry, <span class="number">0</span>, rl.size()-rl.snapLastIdx)</span><br><span class="line">        newLog = <span class="built_in">append</span>(newLog, LogEntry&#123;</span><br><span class="line">                Term: rl.snapLastTerm,</span><br><span class="line">        &#125;)</span><br><span class="line">        newLog = <span class="built_in">append</span>(newLog, rl.tailLog[idx+<span class="number">1</span>:]...)</span><br><span class="line">        rl.tailLog = newLog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快照数据流"><a href="#快照数据流" class="headerlink" title="快照数据流"></a>快照数据流</h2><p>我们遵循一条 <strong>snapshot 数据流</strong>主线，来分四个步骤，一步步实现：</p>
<ol>
<li>Leader 的应用层调用 <code>raft.Snapshot(index, snapshot)</code> 函数<ul>
<li>保存 snapshot</li>
<li>截断日志</li>
<li>持久化</li>
</ul>
</li>
<li>Leader 在需要时使用该 <code>snapshot</code> 构造参数发送 RPC 给 Follower</li>
<li>Follower 接收到 Leader RPC 后替换本地日志，并将其持久化</li>
<li>Follower 通过 <code>ApplyMsg</code> 将 snapshot 传给 Follower 应用层</li>
</ol>
<p><img src="https://www.freeimg.cn/i/2024/02/08/65c44fbcf33c4.png"></p>
<h3 id="调用-Snapshot-接口"><a href="#调用-Snapshot-接口" class="headerlink" title="调用 Snapshot() 接口"></a>调用 <code>Snapshot()</code> 接口</h3><p>Leader 的应用层调用 <code>Snapshot(index, snapshot)</code> 接口后，我们会在 <code>index</code> 处截断现有日志，将 <code>snapshot</code> 保存在 <code>rf.log</code> 中，同时将其持久化，以应对可能得宕机重启。</p>
<p>这里需要说明的是，我们将 <code>RafLog</code> 中：</p>
<ol>
<li>应用层（包括 Leader 和 Follower）主动做 snapshot 的接口称为 <code>RaftLog.doSnapshot</code></li>
<li>将 Follower 收到 RPC 后被动做 snapshot 的接口称为：<code>RaftLog.installSnapshot</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- raft_compaction.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Snapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line">        <span class="comment">// Your code here (PartD).</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        rf.log.doSnapshot(index, snapshot)</span><br><span class="line">        rf.persistLocked()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上一节，我们没有对 <code>snapshot</code> 字段持久化，本节，我们在 <code>rf.persistLocked() </code>接口中，需要对其进行持久化。和其他字段不同，<code>snapshot</code> 需要使用 <code>rf.persister.Save</code> 接口的第二个参数来持久化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- raft_persistence.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> persistLocked() &#123;</span><br><span class="line">        w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">        e := labgob.NewEncoder(w)</span><br><span class="line">        e.Encode(rf.currentTerm)</span><br><span class="line">        e.Encode(rf.votedFor)</span><br><span class="line">        rf.log.persist(e)</span><br><span class="line">        raftstate := w.Bytes()</span><br><span class="line">        rf.persister.Save(raftstate, rf.log.snapshot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送-InstallSnapshot"><a href="#发送-InstallSnapshot" class="headerlink" title="发送 InstallSnapshot"></a>发送 <code>InstallSnapshot</code></h3><p>当 Leader 试图给 Follower 同步日志时，如果发现要携带的 <code>AppendEntriesArgs.Entries</code> 有部分已经被截断了，则需要先发送 Snapshot 。</p>
<p>这里有个<strong>边界条件</strong>——<code>AppendEntriesArgs.PrevLogIndex</code> 等于 <code>RaftLog.snapLastIdx </code>时。由于我们上一节在 <code>RaftLog.snapLastIdx</code> 处 mock 了一个携带 <code>snapLastTerm</code> 的假的日志条目，此条件下并不需要发送 Snapshot。</p>
<p>因此，需要发送 Snapshot 的条件是：**<code>AppendEntriesArgs.PrevLogIndex &lt; rf.log.snapLastIdx</code>**  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- raft_replication.go</span></span><br><span class="line"><span class="comment">// only valid in the given `term`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startReplication(term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">                reply := &amp;AppendEntriesReply&#123;&#125;</span><br><span class="line">                ok := rf.sendAppendEntries(peer, args, reply)</span><br><span class="line"></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">                <span class="comment">// --- some codes omitted</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// align the term</span></span><br><span class="line">                <span class="comment">// --- some codes omitted</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// check context lost</span></span><br><span class="line">                <span class="comment">// --- some codes omitted</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// hanle the reply</span></span><br><span class="line">                <span class="comment">// probe the lower index if the prevLog not matched</span></span><br><span class="line">                <span class="keyword">if</span> !reply.Success &#123;</span><br><span class="line">                        <span class="comment">// --- some codes omitted</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// LogEntry in `nextPrevIdx` may be truncated</span></span><br><span class="line">                        <span class="comment">// so we should check it separately </span></span><br><span class="line">                        nextPrevIdx := rf.nextIndex[peer] - <span class="number">1</span></span><br><span class="line">                        nextPrevTerm := InvalidTerm</span><br><span class="line">                        <span class="keyword">if</span> nextPrevIdx &gt;= rf.log.snapLastIdx &#123;</span><br><span class="line">                                nextPrevTerm = rf.log.at(nextPrevIdx).Term</span><br><span class="line">                        &#125;</span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;-&gt; S%d, Not matched at Prev=[%d]T%d, Try next Prev=[%d]T%d&quot;</span>,</span><br><span class="line">                                peer, args.PrevLogIndex, args.PrevLogTerm, nextPrevIdx, nextPrevTerm)</span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;-&gt; S%d, Leader log=%v&quot;</span>, peer, rf.log.String())</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// update match/next index if log appended successfully</span></span><br><span class="line">                rf.matchIndex[peer] = args.PrevLogIndex + <span class="built_in">len</span>(args.Entries) <span class="comment">// important</span></span><br><span class="line">                rf.nextIndex[peer] = rf.matchIndex[peer] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// update the commitIndex</span></span><br><span class="line">                <span class="comment">// --- some codes omitted</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rf.contextLostLocked(Leader, term) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;Lost Leader[%d] to %s[T%d]&quot;</span>, term, rf.role, rf.currentTerm)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                <span class="comment">// --- some codes omitted</span></span><br><span class="line"></span><br><span class="line">                prevIdx := rf.nextIndex[peer] - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> prevIdx &lt; rf.log.snapLastIdx &#123;</span><br><span class="line">                        args := &amp;InstallSnapshotArgs&#123;</span><br><span class="line">                                Term:              rf.currentTerm,</span><br><span class="line">                                LeaderId:          rf.me,</span><br><span class="line">                                LastIncludedIndex: rf.log.snapLastIdx,</span><br><span class="line">                                LastIncludedTerm:  rf.log.snapLastTerm,</span><br><span class="line">                                Snapshot:          rf.log.snapshot,</span><br><span class="line">                        &#125;</span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;-&gt; S%d, InstallSnap, Args=%v&quot;</span>, peer, args.String())</span><br><span class="line">                        <span class="keyword">go</span> rf.installOnPeer(peer, term, args)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                prevTerm := rf.log.at(prevIdx).Term</span><br><span class="line">                args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">                        <span class="comment">// --- some codes omitted</span></span><br><span class="line">                &#125;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;-&gt; S%d, Append, Args=%v&quot;</span>, peer, args.String())</span><br><span class="line">                <span class="keyword">go</span> replicateToPeer(peer, args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是在 <code>raft_compaction.go</code> 中定义 <code>InstallSnapshot</code> RPC 相关结构体，并发送 RPC。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- raft_compaction.go</span></span><br><span class="line"><span class="keyword">type</span> InstallSnapshotArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">        Term     <span class="type">int</span></span><br><span class="line">        LeaderId <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        LastIncludedIndex <span class="type">int</span></span><br><span class="line">        LastIncludedTerm  <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        Snapshot []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(args *InstallSnapshotArgs)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Leader-%d, T%d, Last: [%d]T%d&quot;</span>, args.LeaderId, args.Term, args.LastIncludedIndex, args.LastIncludedTerm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> InstallSnapshotReply <span class="keyword">struct</span> &#123;</span><br><span class="line">        Term <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(reply *InstallSnapshotReply)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;T%d&quot;</span>, reply.Term)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> sendInstallSnapshot(server <span class="type">int</span>, args *InstallSnapshotArgs, reply *InstallSnapshotReply) <span class="type">bool</span> &#123;</span><br><span class="line">        ok := rf.peers[server].Call(<span class="string">&quot;Raft.InstallSnapshot&quot;</span>, args, reply)</span><br><span class="line">        <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> installOnPeer(peer, term <span class="type">int</span>, args *InstallSnapshotArgs) &#123;</span><br><span class="line">        reply := &amp;InstallSnapshotReply&#123;&#125;</span><br><span class="line">        ok := rf.sendInstallSnapshot(peer, args, reply)</span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DSnap, <span class="string">&quot;-&gt; S%d, Lost or crashed&quot;</span>, peer)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;-&gt; S%d, InstallSnap, Reply=%v&quot;</span>, peer, reply.String())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(reply.Term)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// update the match and next</span></span><br><span class="line">        <span class="keyword">if</span> args.LastIncludedIndex &gt; rf.matchIndex[peer] &#123; <span class="comment">// to avoid disorder reply</span></span><br><span class="line">                rf.matchIndex[peer] = args.LastIncludedIndex</span><br><span class="line">                rf.nextIndex[peer] = args.LastIncludedIndex + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// note: we need not try to update the commitIndex again,</span></span><br><span class="line">        <span class="comment">// because the snapshot included indexes are all committed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点有二：</p>
<ol>
<li><strong>记得更新</strong>：在处理 <code>InstallSnapshotReply</code> 时，很容易忘了更新 <code>matchIndex</code> 和 <code>nextIndex</code>，这会造成不断重复发 <code>InstallSnapshot</code> RPC。</li>
<li><strong>条件更新</strong>：主要为了处理 RPC Reply 乱序返回的情况。仅仅在 <code>args.LastIncludedIndex &gt; rf.matchIndex[peer]</code> 才更新，这是因为，如果有多个 <code>InstallSnapshotReply</code> 乱序回来，且较小的 <code>args.LastIncludedIndex</code> 后回来的话，如果不加判断，会造成<code>matchIndex</code> 和 <code>nextIndex</code> 的反复横跳。</li>
</ol>
<h3 id="接受-InstallSnapshot"><a href="#接受-InstallSnapshot" class="headerlink" title="接受 InstallSnapshot"></a>接受 <code>InstallSnapshot</code></h3><p>Follower 在收到 <code>InstallSnapshot</code> 时，还是要首先<strong>对齐 Term</strong>。之后，要判断该 Snapshot 是否有必要接受：如果本地已经有 Snapshot，且其下标已经包含 <code>args.LastIncludedIndex</code> ，则拒绝即可。见下面代码中标红部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- raft_compaction.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;&lt;- S%d, RecvSnap, Args=%v&quot;</span>, args.LeaderId, args.String())</span><br><span class="line"></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DSnap, <span class="string">&quot;&lt;- S%d, Reject Snap, Higher Term, T%d&gt;T%d&quot;</span>, args.LeaderId, rf.currentTerm, args.Term)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(args.Term)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check if it is a RPC which is out of order</span></span><br><span class="line">        <span class="keyword">if</span> rf.log.snapLastIdx &gt;= args.LastIncludedIndex &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DSnap, <span class="string">&quot;&lt;- S%d, Reject Snap, Already installed, Last: %d&gt;=%d&quot;</span>, args.LeaderId, rf.log.snapLastIdx, args.LastIncludedIndex)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// install the snapshot</span></span><br><span class="line">        rf.log.installSnapshot(args.LastIncludedIndex, args.LastIncludedTerm, args.Snapshot)</span><br><span class="line">        rf.persistLocked()</span><br><span class="line">        rf.snapPending = <span class="literal">true</span></span><br><span class="line">        rf.applyCond.Signal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Follower <code>InstallSnapshot</code> 到 Raft 层时，需要做两件事：</p>
<ol>
<li>利用该 snapshot 重置 <code>rf.log</code> ：<code>installSnapshot</code></li>
<li>对该 snapshot 进行持久化，以供宕机重启后载入：<code>rf.persistLocked()</code></li>
</ol>
<p>两者顺序不能颠倒，因为 <code>rf.persistLocked()</code> 时需要用到 <code>rf.log</code> 中的新保存的 snapshot，这算个<strong>隐式依赖</strong>，其实风格不太好，在工程实践中尽量避免，或者增加一些详细注释。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- raft_log.go</span></span><br><span class="line"><span class="comment">// isntall snapshot from the leader to the follower</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RaftLog)</span></span> installSnapshot(index, term <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line">        rl.snapLastIdx = index</span><br><span class="line">        rl.snapLastTerm = term</span><br><span class="line">        rl.snapshot = snapshot</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make a new log array</span></span><br><span class="line">        <span class="comment">// just discard all the local log, and use the leader&#x27;s snapshot</span></span><br><span class="line">        newLog := <span class="built_in">make</span>([]LogEntry, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        newLog = <span class="built_in">append</span>(newLog, LogEntry&#123;</span><br><span class="line">                Term: rl.snapLastTerm,</span><br><span class="line">        &#125;)</span><br><span class="line">        rl.tailLog = newLog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Follower 将 snapshot 保存到<code>rf.log</code> 中时，完全覆盖掉以前日志就可以。因为新来的 snapshot 的最后一条日志下标（ <code>lastIncludeIndex</code> ）一定是大于原来 Follower log 的最后一条 index 的（即 Leader 发过来的 snapshot 肯定包含更多信息），否则 Leader 就不需要发送 snapshot 给 Follower 了。</p>
<h3 id="应用-snapshot"><a href="#应用-snapshot" class="headerlink" title="应用 snapshot"></a>应用 <code>snapshot</code></h3><p>当 Follower 在 Raft 层持久化以后，还要通过 <code>rf.applyCh</code> 发送到应用层进行 apply。为了保证所有的 apply 串行执行，我们将所有的 apply 逻辑都收束到 <code>applicationTicker</code> 线程中。</p>
<p>为此，我们在 Raft 结构体中新引入一个标记变量 <code>snapPending</code>，当 Follower 收到 snapshot 时，就设置该标记，并且通过 <code>rf.applyCond</code> 唤醒 <code>applicationTicker</code> 进行 apply。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- raft_application.go </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> applicationTicker() &#123;</span><br><span class="line">        <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                rf.applyCond.Wait()</span><br><span class="line">                entries := <span class="built_in">make</span>([]LogEntry, <span class="number">0</span>)</span><br><span class="line">                snapPendingInstall := rf.snapPending</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> !snapPendingInstall &#123;</span><br><span class="line">                        <span class="keyword">for</span> i := rf.lastApplied + <span class="number">1</span>; i &lt;= rf.commitIndex; i++ &#123;</span><br><span class="line">                                entries = <span class="built_in">append</span>(entries, rf.log.at(i))</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> !snapPendingInstall &#123;</span><br><span class="line">                        <span class="keyword">for</span> i, entry := <span class="keyword">range</span> entries &#123;</span><br><span class="line">                                rf.applyCh &lt;- ApplyMsg&#123;</span><br><span class="line">                                        CommandValid: entry.CommandValid,</span><br><span class="line">                                        Command:      entry.Command,</span><br><span class="line">                                        CommandIndex: rf.lastApplied + <span class="number">1</span> + i, <span class="comment">// must be cautious</span></span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        rf.applyCh &lt;- ApplyMsg&#123;</span><br><span class="line">                                SnapshotValid: <span class="literal">true</span>,</span><br><span class="line">                                Snapshot:      rf.log.snapshot,</span><br><span class="line">                                SnapshotIndex: rf.log.snapLastIdx,</span><br><span class="line">                                SnapshotTerm:  rf.log.snapLastTerm,</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                <span class="keyword">if</span> !snapPendingInstall &#123;</span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DApply, <span class="string">&quot;Apply log for [%d, %d]&quot;</span>, rf.lastApplied+<span class="number">1</span>, rf.lastApplied+<span class="built_in">len</span>(entries))</span><br><span class="line">                        rf.lastApplied += <span class="built_in">len</span>(entries)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DApply, <span class="string">&quot;Install Snapshot for [0, %d]&quot;</span>, rf.log.snapLastIdx)</span><br><span class="line">                        rf.lastApplied = rf.log.snapLastIdx</span><br><span class="line">                        <span class="keyword">if</span> rf.commitIndex &lt; rf.lastApplied &#123;</span><br><span class="line">                                rf.commitIndex = rf.lastApplied</span><br><span class="line">                        &#125;</span><br><span class="line">                        rf.snapPending = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 applicationTicker 原来的逻辑是三段式的：</p>
<ol>
<li>临界区（加锁）内，提取要 apply 的数据</li>
<li>临界区外，通过 channel 进行 apply</li>
<li>临界区内，更新相关变量</li>
</ol>
<p>我们新增的 apply snapshot 逻辑也保持这样的三段式，分别增加一段逻辑，并通过 <code>snapPending</code> 进行区分，本次 apply 是 apply log 还是 apply snapshot。</p>
<p>如上述代码标红部分，需要注意的是 apply 了 snapshot 之后，要：</p>
<ol>
<li>更新 <code>commitIndex</code> 和 <code>lastApplied</code> ：避免 apply 到和 snapshot 有交叠的日志</li>
<li>清除 <code>snapPending</code> 标记位：避免重复 apply snapshot</li>
</ol>
<h2 id="BUG-修复"><a href="#BUG-修复" class="headerlink" title="BUG 修复"></a>BUG 修复</h2><p>问题包括两部分：</p>
<ol>
<li>在 Snapshot 时对 index 的检查</li>
<li>使用 rf.log.at 前对传入下标的检查</li>
</ol>
<h3 id="Snapshot-下标检查"><a href="#Snapshot-下标检查" class="headerlink" title="Snapshot 下标检查"></a>Snapshot 下标检查</h3><p>之前只检查了下界 <code>rf.log.snapLastIdx </code>（不要重复进行 snapshot），但也要加上检查上界：<code>rf.commitIndex</code>。即，不能对没有提交的日志进行 snapshot。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- raft_compaction.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Snapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line">        <span class="comment">// Your code here (PartD).</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> index &gt; rf.commitIndex &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DSnap, <span class="string">&quot;Couldn&#x27;t snapshot before CommitIdx: %d&gt;%d&quot;</span>, index, rf.commitIndex)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index &lt;= rf.log.snapLastIdx &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DSnap, <span class="string">&quot;Already snapshot in %d&lt;=%d&quot;</span>, index, rf.log.snapLastIdx)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.log.doSnapshot(index, snapshot)</span><br><span class="line">        rf.persistLocked()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LogRaft-at-下标检查"><a href="#LogRaft-at-下标检查" class="headerlink" title="LogRaft.at 下标检查"></a><code>LogRaft.at</code> 下标检查</h3><p>每次使用 RaftLog.at 函数时，都要保证其传入参数落入 <code>[RaftLog.snapLastIdx, RaftLog.size()-1]</code> 的区间内，有的地方可以通过逻辑来隐式保证，但有些地方由于并发的问题，必须要进行显式地检查。</p>
<p>主要包括 <code>applicationTicker</code> 的 Loop 中逻辑。Apply Log 之前会把所有 <code>(lastAppiled, commitIndex]</code> 的日志取出来，但有可能这个区间会超出 <code>rf.log</code> 中所保存的 <code>tailLog</code> 日志区间，因此要做剪裁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> applicationTicker() &#123;</span><br><span class="line">        <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                rf.applyCond.Wait()</span><br><span class="line">                entries := <span class="built_in">make</span>([]LogEntry, <span class="number">0</span>)</span><br><span class="line">                snapPendingApply := rf.snapPending</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> !snapPendingApply &#123;</span><br><span class="line">                        <span class="keyword">if</span> rf.lastApplied &lt; rf.log.snapLastIdx &#123;</span><br><span class="line">                                rf.lastApplied = rf.log.snapLastIdx</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// make sure that the rf.log have all the entries</span></span><br><span class="line">                        start := rf.lastApplied + <span class="number">1</span></span><br><span class="line">                        end := rf.commitIndex</span><br><span class="line">                        <span class="keyword">if</span> end &gt;= rf.log.size() &#123;</span><br><span class="line">                                end = rf.log.size() - <span class="number">1</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class="line">                                entries = <span class="built_in">append</span>(entries, rf.log.at(i))</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// --- some code ommited here</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><ol>
<li><strong>应用层调用</strong> <strong><code>snapshot(index, snapshot)</code>意味着 什么？</strong><ol>
<li>对应用层意味着：<ol>
<li>应用已经做好了一个快照，但编解码方式之后应用层自己知道，Raft 层不感知。</li>
<li>应用层自己也会保存该快照，之后宕机重启后会先加载该快照。此时（宕机重启后） Raft 层也要记得更新自己的 <code>commitIndex</code> 和 <code>lastApplied</code>。</li>
</ol>
</li>
<li>对 Raft 层意味着：<ol>
<li>应用层告诉 Raft 层，你可以把 index 及以前的日志给释放掉了。</li>
<li>Raft 层要保存下 Snapshot，万一其变为 Leader 之后需要给 Follower 发。</li>
<li>保存分为在内存中保存和持久化到外存。</li>
</ol>
</li>
</ol>
</li>
<li>**宕机重启后， **<code>lastApplied</code><strong>怎么初始化？</strong><ol>
<li><strong>如果有 snapshot 存在</strong>：则需要初始化为 snapshot 的 <code>lastIncludedIndex</code>。因为应用层肯定也是从自己 snapshot 中来恢复的。<ol>
<li>在 Make 阶段同步的再 apply 一个 snapshot 到 <code>appplyCh</code> 中有可能会直接 block 住。</li>
<li>即使不阻塞，有时候也会遇到 <code>snapshot decode error </code>报错。</li>
</ol>
</li>
<li>如果没有 snapshot 存在<strong>：那就初始化为 0 。</strong></li>
<li>如果初始化为 snapLastIndex，那前面的需要 apply 吗？<ul>
<li>不需要，因为应用层自己会从自己保存的 snapshot 中恢复。</li>
</ul>
</li>
</ol>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">ytf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/02/06/raft/">http://example.com/2024/02/06/raft/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">ytfの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Mit6-5840/">Mit6.5840</a></div><div class="post_share"><div class="social-share" data-image="https://www.freeimg.cn/i/2024/03/01/65e19472e086e.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/28/lab3/" title="raftkv"><img class="cover" src="https://www.freeimg.cn/i/2024/03/01/65e194b0d42e7.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">raftkv</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/25/MapReduce/" title="MapReduce"><img class="cover" src="https://www.freeimg.cn/i/2024/03/01/65e1942a659f9.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MapReduce</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/01/25/MapReduce/" title="MapReduce"><img class="cover" src="https://www.freeimg.cn/i/2024/03/01/65e1942a659f9.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-25</div><div class="title">MapReduce</div></div></a></div><div><a href="/2024/02/28/lab3/" title="raftkv"><img class="cover" src="https://www.freeimg.cn/i/2024/03/01/65e194b0d42e7.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-28</div><div class="title">raftkv</div></div></a></div><div><a href="/2024/02/29/shardkv/" title="shardkv"><img class="cover" src="https://www.freeimg.cn/i/2024/03/01/65e193c89bb7b.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-29</div><div class="title">shardkv</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ytf</div><div class="author-info__description">cs</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/TengFeiyang01/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/TengFeiyang01" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2196442691@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=2196442691&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #qq-color-code;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎大家来到我的博客！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Raft%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">Raft分布式共识算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PartA-%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE"><span class="toc-number">2.</span> <span class="toc-text">PartA 领导选举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.</span> <span class="toc-text">状态转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E9%80%BB%E8%BE%91"><span class="toc-number">2.2.</span> <span class="toc-text">选举逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E4%B8%BE-loop"><span class="toc-number">2.2.1.</span> <span class="toc-text">选举 loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%BD%AE%E9%80%89%E4%B8%BE"><span class="toc-number">2.2.2.</span> <span class="toc-text">单轮选举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A3%80%E6%9F%A5"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">上下文检查</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%AC%A1-RPC"><span class="toc-number">2.2.3.</span> <span class="toc-text">单次 RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90%E4%BB%BB%E6%9C%9F"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">对齐任期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">回调函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E9%80%BB%E8%BE%91"><span class="toc-number">2.3.</span> <span class="toc-text">心跳逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3-Loop"><span class="toc-number">2.3.1.</span> <span class="toc-text">心跳 Loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%BD%AE%E5%BF%83%E8%B7%B3"><span class="toc-number">2.3.2.</span> <span class="toc-text">单轮心跳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%AC%A1-RPC-1"><span class="toc-number">2.3.3.</span> <span class="toc-text">单次 RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-1"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">回调函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%A6%81%E7%82%B9"><span class="toc-number">2.4.</span> <span class="toc-text">实现要点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PartB-%E6%97%A5%E5%BF%97%E5%90%8C%E6%AD%A5"><span class="toc-number">3.</span> <span class="toc-text">PartB 日志同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">日志复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%8C%E5%96%84"><span class="toc-number">3.1.1.</span> <span class="toc-text">结构体完善</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AppendEntries-RPC-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">AppendEntries RPC 结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Raft-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">Raft 结构体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PC-%E6%8E%A5%E6%94%B6%E6%96%B9"><span class="toc-number">3.1.2.</span> <span class="toc-text">PC 接收方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC-%E5%8F%91%E9%80%81%E6%96%B9"><span class="toc-number">3.1.3.</span> <span class="toc-text">RPC 发送方</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E6%97%A5%E5%BF%97%E6%AF%94%E8%BE%83"><span class="toc-number">3.2.</span> <span class="toc-text">选举日志比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%96%B0%E6%97%A7%E6%AF%94%E8%BE%83"><span class="toc-number">3.2.1.</span> <span class="toc-text">日志新旧比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E6%97%A5%E5%BF%97%E6%AF%94%E8%BE%83"><span class="toc-number">3.2.2.</span> <span class="toc-text">增加日志比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%BA%94%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">日志应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Apply-%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">3.3.1.</span> <span class="toc-text">Apply 工作流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leader-CommitIndex-%E6%9B%B4%E6%96%B0"><span class="toc-number">3.3.2.</span> <span class="toc-text">Leader CommitIndex 更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Follower-CommitIndex-%E6%9B%B4%E6%96%B0"><span class="toc-number">3.3.3.</span> <span class="toc-text">Follower CommitIndex 更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%A6%81%E7%82%B9-1"><span class="toc-number">3.4.</span> <span class="toc-text">实现要点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Context-%E6%A3%80%E6%9F%A5"><span class="toc-number">3.4.1.</span> <span class="toc-text">Context 检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Start-%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.2.</span> <span class="toc-text">Start 实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PartC-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">PartC 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.</span> <span class="toc-text">逻辑实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">4.1.1.</span> <span class="toc-text">序列化和反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">函数调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#readPersist"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">readPersist</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#persistLocked"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">persistLocked</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%9B%9E%E6%BA%AF%E4%BC%98%E5%8C%96"><span class="toc-number">4.1.3.</span> <span class="toc-text">日志回溯优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bug-%E4%BF%AE%E5%A4%8D"><span class="toc-number">4.2.</span> <span class="toc-text">Bug 修复</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PartD-%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9"><span class="toc-number">5.</span> <span class="toc-text">PartD 日志压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%A6%81%E6%B1%82"><span class="toc-number">5.1.</span> <span class="toc-text">实现要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E9%87%8D%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">日志重构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RaftLog-%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.1.</span> <span class="toc-text">RaftLog 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">结构体字段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.2.2.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E6%93%8D%E4%BD%9C"><span class="toc-number">5.2.3.</span> <span class="toc-text">下标操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.4.</span> <span class="toc-text">辅助函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Snapshot-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.5.</span> <span class="toc-text">Snapshot 基本实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">5.3.</span> <span class="toc-text">快照数据流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-Snapshot-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.3.1.</span> <span class="toc-text">调用 Snapshot() 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81-InstallSnapshot"><span class="toc-number">5.3.2.</span> <span class="toc-text">发送 InstallSnapshot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97-InstallSnapshot"><span class="toc-number">5.3.3.</span> <span class="toc-text">接受 InstallSnapshot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-snapshot"><span class="toc-number">5.3.4.</span> <span class="toc-text">应用 snapshot</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BUG-%E4%BF%AE%E5%A4%8D"><span class="toc-number">5.4.</span> <span class="toc-text">BUG 修复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Snapshot-%E4%B8%8B%E6%A0%87%E6%A3%80%E6%9F%A5"><span class="toc-number">5.4.1.</span> <span class="toc-text">Snapshot 下标检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LogRaft-at-%E4%B8%8B%E6%A0%87%E6%A3%80%E6%9F%A5"><span class="toc-number">5.4.2.</span> <span class="toc-text">LogRaft.at 下标检查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">一些问题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/29/shardkv/" title="shardkv"><img src="https://www.freeimg.cn/i/2024/03/01/65e193c89bb7b.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="shardkv"/></a><div class="content"><a class="title" href="/2024/02/29/shardkv/" title="shardkv">shardkv</a><time datetime="2024-02-29T02:39:32.000Z" title="发表于 2024-02-29 10:39:32">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/28/lab3/" title="raftkv"><img src="https://www.freeimg.cn/i/2024/03/01/65e194b0d42e7.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="raftkv"/></a><div class="content"><a class="title" href="/2024/02/28/lab3/" title="raftkv">raftkv</a><time datetime="2024-02-28T00:54:46.000Z" title="发表于 2024-02-28 08:54:46">2024-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/06/raft/" title="Raft"><img src="https://www.freeimg.cn/i/2024/03/01/65e19472e086e.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Raft"/></a><div class="content"><a class="title" href="/2024/02/06/raft/" title="Raft">Raft</a><time datetime="2024-02-06T04:54:51.000Z" title="发表于 2024-02-06 12:54:51">2024-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/25/MapReduce/" title="MapReduce"><img src="https://www.freeimg.cn/i/2024/03/01/65e1942a659f9.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MapReduce"/></a><div class="content"><a class="title" href="/2024/01/25/MapReduce/" title="MapReduce">MapReduce</a><time datetime="2024-01-25T11:47:16.000Z" title="发表于 2024-01-25 19:47:16">2024-01-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By ytf</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'TengFeiyang01/TengFeiyang01.github.io',
      'data-repo-id': 'R_kgDOLIXuiw',
      'data-category-id': 'DIC_kwDOLIXui84Cdoxk',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !true) {
    if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>