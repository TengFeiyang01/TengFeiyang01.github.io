<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Raft | ytfの博客</title><meta name="author" content="ytf"><meta name="copyright" content="ytf"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一个 Raft 实例（Raft Peer）的主要有三个工作流：  领导选举（leader election） 日志同步（ log replication） 日志应用（log application）  PartA 领导选举实现 Raft 选举和心跳逻辑（即不带日志条目的 AppendEntries）。本部分仅要求实现：  选出唯一的领导者，领导者选出后会持续进行心跳避免其他人发起选举 旧的领导者宕">
<meta property="og:type" content="article">
<meta property="og:title" content="Raft">
<meta property="og:url" content="http://example.com/2024/02/06/raft/index.html">
<meta property="og:site_name" content="ytfの博客">
<meta property="og:description" content="一个 Raft 实例（Raft Peer）的主要有三个工作流：  领导选举（leader election） 日志同步（ log replication） 日志应用（log application）  PartA 领导选举实现 Raft 选举和心跳逻辑（即不带日志条目的 AppendEntries）。本部分仅要求实现：  选出唯一的领导者，领导者选出后会持续进行心跳避免其他人发起选举 旧的领导者宕">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-02-06T04:54:51.000Z">
<meta property="article:modified_time" content="2024-02-06T04:58:42.650Z">
<meta property="article:author" content="ytf">
<meta property="article:tag" content="Mit6.5840">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/02/06/raft/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Raft',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-02-06 12:58:42'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="ytfの博客"><span class="site-name">ytfの博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Raft</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-06T04:54:51.000Z" title="发表于 2024-02-06 12:54:51">2024-02-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-06T04:58:42.650Z" title="更新于 2024-02-06 12:58:42">2024-02-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Raft"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>一个 Raft 实例（Raft Peer）的主要有三个工作流：</p>
<ol>
<li>领导选举（leader election）</li>
<li>日志同步（ log replication）</li>
<li>日志应用（log application）</li>
</ol>
<h1 id="PartA-领导选举"><a href="#PartA-领导选举" class="headerlink" title="PartA 领导选举"></a>PartA 领导选举</h1><p>实现 Raft 选举和<strong>心跳逻辑</strong>（即不带日志条目的 AppendEntries）。本部分仅要求实现：</p>
<ol>
<li>选出<strong>唯一</strong>的领导者，领导者选出后会持续进行心跳避免其他人发起选举</li>
<li>旧的领导者宕机或者网络故障无法触达时，选出<strong>新的</strong>领导者</li>
</ol>
<p>我们可以将 PartA 的实现分为三部分：</p>
<ol>
<li><strong>状态转换</strong>：角色定义和三个状态转换函数</li>
<li><strong>选举逻辑</strong>：定义选举 RPC 相关结构体，构造周期性发送请求的 Loop</li>
<li><strong>心跳逻辑</strong>：定义心跳 RPC 相关结构体（只有心跳，因此不涉及日志），当选 Leader 后发送心跳</li>
</ol>
<p>在开始实现逻辑之前，要根据论文图 2 定义 Raft 用到的基本数据结构，如前所述，PartA 暂时不用管日志相关字段和逻辑。下面代码中，上面部分是代码框架为了测试默认给的，加粗部分是本部分新加的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Go object implementing a single Raft peer.</span></span><br><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">        mu        sync.Mutex          <span class="comment">// Lock to protect shared access to this peer&#x27;s state</span></span><br><span class="line">        peers     []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">        persister *Persister          <span class="comment">// Object to hold this peer&#x27;s persisted state</span></span><br><span class="line">        me        <span class="type">int</span>                 <span class="comment">// this peer&#x27;s index into peers[]</span></span><br><span class="line">        dead      <span class="type">int32</span>               <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Your data here (PartA, PartB, PartC).</span></span><br><span class="line">        <span class="comment">// Look at the paper&#x27;s Figure 2 for a description of what</span></span><br><span class="line">        <span class="comment">// state a Raft server must maintain.</span></span><br><span class="line">        role        Role</span><br><span class="line">        currentTerm <span class="type">int</span></span><br><span class="line">        votedFor     <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// used for election loop</span></span><br><span class="line">        electionStart   time.Time</span><br><span class="line">        electionTimeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：在工程实践中，<code>currentTerm</code> 一般会建议用指定位数的整形，比如 <code>int32</code>，但这里为了简单就直接用 <code>int</code> 了。</p>
<p>修改关键函数 <code>GetState</code>，是测试框架能够正确拿到 Raft 相关状态，否则可能会出现测试框架认为一直选不出主的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return currentTerm and whether this server</span></span><br><span class="line"><span class="comment">// believes it is the leader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> GetState() (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">        <span class="comment">// Your code here (PartA).</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> rf.currentTerm, rf.role == Leader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><p>状态转换是针对 Peer 角色的，因此需要先定义<strong>角色类型</strong>和<strong>常量</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Role <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        Follower  Role = <span class="string">&quot;Follower&quot;</span></span><br><span class="line">        Candidate Role = <span class="string">&quot;Candidate&quot;</span></span><br><span class="line">        Leader    Role = <span class="string">&quot;Leader&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在此之上，参考论文中的状态机构建状态转换函数。</p>
<p><img src="/assets/65c088ce75624.png"></p>
<p>可以实现为三个状态转换函数：<code>becomeCandidate</code>，<code>becomeLeader</code> 和 <code>becomeFollower</code>。由于涉及修改 Raft 的全局状态，需要加锁，且我们期望在函数外边加锁。按照之前提到的命名规则，对每个函数需要带上 <code>Locked</code> 后缀，表明需要在加锁的临界区中调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// become a follower in `term`, term could not be decreased</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeFollowerLocked(term <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> term &lt; rf.currentTerm &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DError, <span class="string">&quot;Can&#x27;t become Follower, lower term&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;%s -&gt; Follower, For T%d-&gt;T%d&quot;</span>, </span><br><span class="line">            rf.role, rf.currentTerm, term)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// important! Could only reset the `votedFor` when term increased</span></span><br><span class="line">        <span class="keyword">if</span> term &gt; rf.currentTerm &#123; </span><br><span class="line">                rf.votedFor = <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.role = Follower</span><br><span class="line">        rf.currentTerm = term</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeCandidateLocked() &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.role == Leader &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DError, <span class="string">&quot;Leader can&#x27;t become Candidate&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;%s -&gt; Candidate, For T%d-&gt;T%d&quot;</span>, </span><br><span class="line">            rf.role, rf.currentTerm, rf.currentTerm+<span class="number">1</span>)</span><br><span class="line">        rf.role = Candidate</span><br><span class="line">        rf.currentTerm++</span><br><span class="line">    	rf.resetElectionTimerLocked()</span><br><span class="line">        rf.votedFor = rf.me</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeLeaderLocked() &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.role != Candidate &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLeader, </span><br><span class="line">                    <span class="string">&quot;%s, Only candidate can become Leader&quot;</span>, rf.role)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DLeader, <span class="string">&quot;%s -&gt; Leader, For T%d&quot;</span>, </span><br><span class="line">            rf.role, rf.currentTerm)</span><br><span class="line">        rf.role = Leader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，每个状态转换函数可分为两部分：</p>
<ol>
<li><strong>状态检查</strong>：检查 Raft 实例当前状态，看是否满足状态转换条件。</li>
<li><strong>状态修改</strong>：修改 Raft 实例角色，更改相应状态。</li>
</ol>
<h2 id="选举逻辑"><a href="#选举逻辑" class="headerlink" title="选举逻辑"></a>选举逻辑</h2><p>我们以三个层次组织 RPC <strong>发送方</strong>（也就是 Candidate）<strong>要票逻辑</strong>：</p>
<ol>
<li><strong>选举 loop</strong>：但按框架默认的命名方式，我们称之为 <code>electionTicketor</code></li>
<li><strong>单轮选举</strong>：超时成为 Candidate 之后，针对所有 Peer（除自己外）发起一次要票过程，我们称之为 <code>startElection</code>。</li>
<li><strong>单次 RPC</strong>：针对每个 Peer 的 RequestVote 的请求和响应处理，由于要进行计票，需要用到一个局部变量 votes，因此我们使用一个<code>startElection</code> 中的嵌套函数来实现，称为 <code>askVoteFromPeer</code>。</li>
</ol>
<p>还剩一块，就是 RPC <strong>接受方</strong>（其他 Peer）的<strong>投票逻辑</strong>。</p>
<h3 id="选举-loop"><a href="#选举-loop" class="headerlink" title="选举 loop"></a>选举 loop</h3><p>基本逻辑是每次循环时，要进行两项检查：</p>
<ol>
<li>超时检查：看<strong>选举 Timer</strong> 是否已经超时，只有超时后才会真正发起选举。这里有个问题，就是为什么检查间隔（也就是循环中的 <code>time.Sleep(time.Duration(ms) * time.Millisecond)</code> ）间隔也是随机的？因为只有检查间隔也随机才不会造成：超时间隔随机，但由于“等距”检查，造成同样检查间隔时，一同发起选举。</li>
<li><strong>角色检查</strong>：判断是否为 Leader，如果自己已经是 Leader，则自然不用发起选举。因为发起选举的<strong>唯一目的就是当选 Leader</strong>。</li>
</ol>
<p>因此，我们要实现的第一个逻辑就是：随机超时上下界配置和超时检测函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        electionTimeoutMin time.Duration = <span class="number">250</span> * time.Millisecond</span><br><span class="line">        electionTimeoutMax time.Duration = <span class="number">400</span> * time.Millisecond</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> resetElectionTimerLocked() &#123;</span><br><span class="line">        rf.electionStart = time.Now()</span><br><span class="line">        randRange := <span class="type">int64</span>(electionTimeoutMax - electionTimeoutMin)</span><br><span class="line">        rf.electionTimeout = electionTimeoutMin + time.Duration(rand.Int63()%randRange)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> isElectionTimeoutLocked() <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> time.Since(rf.electionStart) &gt; rf.electionTimeout</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>满足条件时，转变为 Candidate ，然后异步地（同步会造成主 Loop 检查延迟）发起选举。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> electionTicker() &#123;</span><br><span class="line">        <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">                <span class="comment">// Your code here (PartA)</span></span><br><span class="line">                <span class="comment">// Check if a leader election should be started.</span></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                <span class="keyword">if</span> rf.role != Leader &amp;&amp; rf.isElectionTimeoutLocked() &#123;</span><br><span class="line">                        rf.becomeCandidateLocked()</span><br><span class="line">                        <span class="keyword">go</span> rf.startElection(rf.currentTerm)</span><br><span class="line">                &#125;</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// pause for a random amount of time between 50 and 350</span></span><br><span class="line">                <span class="comment">// milliseconds.</span></span><br><span class="line">                ms := <span class="number">50</span> + (rand.Int63() % <span class="number">300</span>)</span><br><span class="line">                time.Sleep(time.Duration(ms) * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有用到 Raft 全局变量的地方都要加锁，但注意不要在加锁时进行<strong>同步地</strong>发送RPC。</p>
<p>该 Loop 的生命周期和 Raft Peer 相同，即<strong>在创建 Raft 实例时就在后台开始运行</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span></span> *Raft &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// some code are omitted here</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// start ticker goroutine to start elections</span></span><br><span class="line">        <span class="keyword">go</span> rf.electionTicker()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单轮选举"><a href="#单轮选举" class="headerlink" title="单轮选举"></a>单轮选举</h3><p>一轮选举包括针对除自己外所有 Peer 的一轮要票 RPC，由于需要访问全局变量，所以仍然要加锁。同样的，就不能在持有锁的时候，同步地进行 RPC。需要用 goroutine 异步地对每个 Peer 进行 RPC。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startElection(term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        votes := <span class="number">0</span></span><br><span class="line">        askVoteFromPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *RequestVoteArgs)</span></span> &#123;</span><br><span class="line">            <span class="comment">// send rpc to `peer` and handle the response</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// every time locked </span></span><br><span class="line">        <span class="keyword">if</span> rf.contextLostLocked(Candidate, term) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                <span class="keyword">if</span> peer == rf.me &#123;</span><br><span class="line">                        votes++</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                args := &amp;RequestVoteArgs&#123;</span><br><span class="line">                        Term:        term,</span><br><span class="line">                        CandidateId: rf.me,</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">go</span> askVoteFromPeer(peer, args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="上下文检查"><a href="#上下文检查" class="headerlink" title="上下文检查"></a>上下文检查</h4><p>这里面有个检查“上下文”是否丢失的关键函数：<code>contextLostLocked</code> <strong>。上下文</strong>，在不同的地方有不同的指代。在我们的 Raft 的实现中，“上下文”就是指 <code>Term</code> 和 <code>Role</code>。即在一个任期内，只要你的角色没有变化，就能放心地<strong>推进状态机</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> contextLostLocked(role Role, term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(rf.currentTerm == term &amp;&amp; rf.role == role)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多线程环境中，只有通过锁保护起来的<strong>临界区</strong>内的代码块才可以认为被原子地执行了。由于在 Raft 实现中，我们使用了大量的 goroutine，因此每当线程新进入一个临界区时，要进行 Raft 上下文的检查。如果 Raft 的上下文已经被更改，要及时终止 goroutine，避免对状态机做出错误的改动。</p>
<h3 id="单次-RPC"><a href="#单次-RPC" class="headerlink" title="单次 RPC"></a>单次 RPC</h3><p>单次 RPC 包括<strong>构造 RPC 参数、发送 RPC等待结果、对 RPC 结果进行处理</strong>三个部分。构造参数我们在 <code>startElection</code> 函数内完成了，因此 <code>askVoteFromPeer</code> 函数中就只需要包括后梁部分即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">askVoteFromPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *RequestVoteArgs)</span></span> &#123;</span><br><span class="line">        <span class="comment">// send RPC </span></span><br><span class="line">        reply := &amp;RequestVoteReply&#123;&#125;</span><br><span class="line">        ok := rf.sendRequestVote(peer, args, reply)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// handle the response</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;Ask vote from %d, Lost or error&quot;</span>, peer)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(reply.Term)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check the context</span></span><br><span class="line">        <span class="keyword">if</span> rf.contextLostLocked(Candidate, rf.currentTerm) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;Lost context, abort RequestVoteReply in T%d&quot;</span>, rf.currentTerm)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// count votes</span></span><br><span class="line">        <span class="keyword">if</span> reply.VoteGranted &#123;</span><br><span class="line">                votes++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> votes &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">                rf.becomeLeaderLocked()</span><br><span class="line">                <span class="keyword">go</span> rf.replicationTicker(term)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对齐任期"><a href="#对齐任期" class="headerlink" title="对齐任期"></a>对齐任期</h4><p>在接受到 RPC 或者处理 RPC 返回值时的第一步，就是要<strong>对齐 Term</strong>。因为 Term 在 Raft 中本质上是一种“优先级”或者“权力等级”的体现。<strong>Peer 的 Term 相同，是对话展开的基础</strong>，否则就要先对齐 Term：</p>
<ol>
<li><strong>如果对方 Term 比自己小</strong>：无视请求，通过返回值“亮出”自己的 Term</li>
<li><strong>如果对方 Term 比自己大</strong>：乖乖跟上对方 Term，变成最“菜”的 Follower</li>
</ol>
<p>对齐 Term 之后，还要检查上下文，即处理 RPC （RPC 回调函数也是在其他线程调用的）返回值和处理多线程本质上一样：都要首先确保<strong>上下文</strong>没有丢失，才能驱动状态机。</p>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>所有 Peer 在运行时都有可能收到要票请求，<code>RequestVote</code> 这个回调函数，就是定义该 Peer 收到要票请求的处理逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">        <span class="comment">// Your code here (PartA, PartB).</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        <span class="keyword">if</span> rf.currentTerm &gt; args.Term &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;-&gt; S%d, Reject vote, higher term, T%d&gt;T%d&quot;</span>, args.CandidateId, rf.currentTerm, args.Term)</span><br><span class="line">                reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> rf.currentTerm &lt; args.Term &#123;</span><br><span class="line">                rf.becomeFollowerLocked(args.Term)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check the votedFor</span></span><br><span class="line">        <span class="keyword">if</span> rf.votedFor != <span class="number">-1</span> &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;-&gt; S%d, Reject, Already voted S%d&quot;</span>, args.CandidateId, rf.votedFor)</span><br><span class="line">                reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">        rf.votedFor = args.CandidateId</span><br><span class="line">        rf.resetElectionTimerLocked()</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;-&gt; S%d&quot;</span>, args.CandidateId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="心跳逻辑"><a href="#心跳逻辑" class="headerlink" title="心跳逻辑"></a>心跳逻辑</h2><p>和选举逻辑相对，我们分三个层次来实现 RPC <strong>发送方</strong>：</p>
<ol>
<li><strong>心跳 Loop</strong>：在当选 Leader 后起一个后台线程，等间隔的发送心跳&#x2F;复制日志，称为 <code>replicationTicker</code></li>
<li><strong>单轮心跳</strong>：对除自己外的所有 Peer 发送一个心跳 RPC，称为 <code>startReplication</code></li>
<li><strong>单次 RPC</strong>：对某个 Peer 来发送心跳，并且处理 RPC 返回值，称为 <code>replicateToPeer</code></li>
</ol>
<p>当然，还有 RPC 接收方回调函数的逻辑。</p>
<p>心跳（日志复制）逻辑和选举逻辑实现层次一致、命名风格一致的好处在于，可以减少心智负担，方便调试和维护。</p>
<h3 id="心跳-Loop"><a href="#心跳-Loop" class="headerlink" title="心跳 Loop"></a>心跳 Loop</h3><p>由于不用构造<strong>随机</strong>超时间隔，心跳 Loop 会比选举 Loop 简单很多：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicationTicker(term <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">                ok := rf.startReplication(term)</span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                time.Sleep(replicateInterval)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与选举 Loop 不同的是，这里的 <code>startReplication</code> 有个返回值，主要是检测<strong>上下文</strong>是否还在（ <code>ContextLost</code> ）——一旦发现 Raft Peer 已经不是这个 term 的 Leader 了，就立即退出 Loop。</p>
<h3 id="单轮心跳"><a href="#单轮心跳" class="headerlink" title="单轮心跳"></a>单轮心跳</h3><p>和 Candidate 的选举逻辑相似，Leader 会给除自己之外的其他 Peer 发送心跳。在发送前要检测<strong>上下文</strong>是否还在，如果不在，直接返回 false ——告诉外层循环 <code>replicationTicker</code> 可以终止循环了。</p>
<p>因为 <code>startReplication</code> 的返回值的含义为：是否成功的发起了一轮心跳。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startReplication(term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">                <span class="comment">// send heartbeat RPC and handle the reply</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> rf.contextLostLocked(Leader, term) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLeader, <span class="string">&quot;Leader[T%d] -&gt; %s[T%d]&quot;</span>, term, rf.role, rf.currentTerm)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                <span class="keyword">if</span> peer == rf.me &#123;</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">                        Term:     term,</span><br><span class="line">                        LeaderId: rf.me,</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">go</span> replicateToPeer(peer, args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单次-RPC-1"><a href="#单次-RPC-1" class="headerlink" title="单次 RPC"></a>单次 RPC</h3><p>在不关心日志时，心跳的返回值处理比较简单，只需要对齐下 term 就行。如果后续还要进行其他处理，则还要检查 context 是否丢失。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">        reply := &amp;AppendEntriesReply&#123;&#125;</span><br><span class="line">        ok := rf.sendAppendEntries(peer, args, reply)</span><br><span class="line"></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;-&gt; S%d, Lost or crashed&quot;</span>, peer)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(reply.Term)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="回调函数-1"><a href="#回调函数-1" class="headerlink" title="回调函数"></a>回调函数</h4><p>心跳接收方在收到心跳时，只要 Leader 的 term 不小于自己，就对其进行认可，变为 Follower，并重置选举时钟，承诺一段时间内不发起选举。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// align the term</span></span><br><span class="line">        <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;&lt;- S%d, Reject log&quot;</span>, args.LeaderId)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> args.Term &gt;= rf.currentTerm &#123;</span><br><span class="line">                rf.becomeFollowerLocked(args.Term)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reset the timer</span></span><br><span class="line">        rf.resetElectionTimerLocked()</span><br><span class="line">        reply.Success = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h2><ol>
<li><p>不要忘记实现 <code>GetState()</code> 函数，否则 tester 没有办法知道选出了 Leader。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> GetState() (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">    	rf.mu.Lock()</span><br><span class="line">    	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// Your code here (PartA).</span></span><br><span class="line">    	<span class="keyword">return</span> rf.currentTerm, rf.role == Leader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RPC 字段：golang 在进行 RPC 时，只会序列化所有大写字母开头的字段，因此一定要注意在定义 <code>*Args</code> （如 <code>RequestVoteArgs</code>）和  <code>*Reply</code> 结构体的时候，确保所有字段首字母都是大写的，否则没有办法通过 RPC 传到对端 Peer。</p>
</li>
<li><p><strong>随机超时</strong>：论文中着重强调了，为了避免“活锁”——每个人都不断地选自己，需要让选举超时是随机的。可以使用 golang 的 <a target="_blank" rel="noopener" href="https://pkg.go.dev/math/rand">rand</a> 包来制造随机超时。</p>
</li>
</ol>
<h1 id="PartB-日志同步"><a href="#PartB-日志同步" class="headerlink" title="PartB 日志同步"></a>PartB 日志同步</h1><h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p>PartB 需要定义日志格式，然后在 PartA 心跳逻辑的基础上，补全日志同步的逻辑。总体上来说，Leader 需要维护一个各个 Peer 的进度视图（<code>nextIndex</code> 和 <code>matchIndex</code> 数组）。其中 <code>nextIndex</code> 用于进行<strong>日志同步时</strong>的<strong>匹配点试探</strong>，<code>matchIndex</code> 用于<strong>日志同步成功后</strong>的<strong>匹配点记录</strong>。依据全局匹配点分布，我们可以计算出当前全局的 <code>commitIndex</code>，然后再通过之后轮次的日志复制 RPC 下发给各个 Follower。</p>
<p>每个 Follower 收到 <code>commitIndex</code> 之后，再去 apply 本地的已提交日志到状态机。</p>
<h3 id="结构体完善"><a href="#结构体完善" class="headerlink" title="结构体完善"></a>结构体完善</h3><h4 id="AppendEntries-RPC-结构体"><a href="#AppendEntries-RPC-结构体" class="headerlink" title="AppendEntries RPC 结构体"></a>AppendEntries RPC 结构体</h4><p>根据 <code>ApplyMsg</code> 所需字段，来定义 <code>LogEntry</code> 。然后在此基础上，依照 <a target="_blank" rel="noopener" href="https://raft.github.io/raft.pdf">Raft 论文</a>中的<a target="_blank" rel="noopener" href="https://av6huf2e1k.feishu.cn/docx/JCssdlgF4oRADcxxLqncPpRCn5b#TFfsdXb3boLjVQxpprMcRNHonge">图 2</a>来补全 RPC 涉及到的结构体：<code>AppendEntriesArgs</code> ，<code>AppendEntriesReply</code> 并不需要添加额外字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add log entries according to the ApplyMsg struct</span></span><br><span class="line"><span class="keyword">type</span> LogEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">        Term         <span class="type">int</span></span><br><span class="line">        CommandValid <span class="type">bool</span></span><br><span class="line">        Command      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add the fields about log: </span></span><br><span class="line"><span class="comment">// PrevLogIndex and PrevLogTerm is used to match the log prefix</span></span><br><span class="line"><span class="comment">// Entries is used to append when matched</span></span><br><span class="line"><span class="comment">// LeaderCommit tells the follower to update its own commitIndex</span></span><br><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">        Term     <span class="type">int</span></span><br><span class="line">        LeaderId <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        PrevLogIndex <span class="type">int</span></span><br><span class="line">        PrevLogTerm  <span class="type">int</span></span><br><span class="line">        Entries      []LogEntry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line">        Term    <span class="type">int</span></span><br><span class="line">        Success <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Raft-结构体"><a href="#Raft-结构体" class="headerlink" title="Raft 结构体"></a>Raft 结构体</h4><p>定义了 <code>LogEntry</code> 之后，完善下 raft struct 中相关字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log in Peer&#x27;s local</span></span><br><span class="line">log         []LogEntry</span><br><span class="line"></span><br><span class="line"><span class="comment">// only used when it is Leader,</span></span><br><span class="line"><span class="comment">// log view for each peer</span></span><br><span class="line">nextIndex  []<span class="type">int</span></span><br><span class="line">matchIndex []<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>则 <code>Make</code> 函数也要给上述字段进行初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span></span> *Raft &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log, LogEntry&#123;&#125;)</span><br><span class="line"></span><br><span class="line">        rf.matchIndex = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(rf.peers))</span><br><span class="line">        rf.nextIndex = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(rf.peers))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PC-接收方"><a href="#PC-接收方" class="headerlink" title="PC 接收方"></a>PC 接收方</h3><p>RPC 接收方，即 Leader 以外的其他 Peer。在考虑日志之后，要<strong>增加</strong>以下逻辑：</p>
<ol>
<li>如果 <code>prevLog</code> 不匹配，则返回 <code>Success = False</code></li>
<li>如果 <code>prevLog</code> 匹配，则将参数中的 <code>Entries</code> 追加到本地日志，返回 <code>Success = True</code>。</li>
</ol>
<p>所谓日志匹配：就是<strong>相同 Index 的地方，Term 相同</strong>；即 index 和 term 能唯一确定一条日志，这是因为，Raft 算法保证一个 Term 中最多有（也可能没有）一个 Leader，然后只有该 Leader 能确定日志顺序且同步日志。这样一来，Term 单调递增，每个 Term 只有一个 Leader，则该 Leader 能唯一确定该 Term 内的日志顺序。</p>
<p>此外，之前<strong>纯心跳逻辑</strong>（心跳逻辑和日志复制逻辑共用一个 RPC）只负责压制其他 Peer 发起选举，因此不用给 reply 返回信息。但此时，就需要用到 reply 了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">		<span class="comment">// other code...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// For debug</span></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;&lt;- S%d, Receive log, Prev=[%d]T%d, Len()=%d&quot;</span>, args.LeaderId, args.PrevLogIndex, args.PrevLogTerm, <span class="built_in">len</span>(args.Entries))</span><br><span class="line">        <span class="comment">// replay initialized</span></span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// other code...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// return failure if the previous log not matched</span></span><br><span class="line">        <span class="keyword">if</span> args.PrevLogIndex &gt;= <span class="built_in">len</span>(rf.log) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;&lt;- S%d, Reject Log, Follower log too short, Len:%d &lt;= Prev:%d&quot;</span>, args.LeaderId, <span class="built_in">len</span>(rf.log), args.PrevLogIndex)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;&lt;- S%d, Reject Log, Prev log not match, [%d]: T%d != T%d&quot;</span>, args.LeaderId, args.PrevLogIndex, rf.log[args.PrevLogIndex].Term, args.PrevLogTerm)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// append the leader logs to local</span></span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log[:args.PrevLogIndex+<span class="number">1</span>], args.Entries...)</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DLog2, <span class="string">&quot;Follower append logs: (%d, %d]&quot;</span>, args.PrevLogIndex, args.PrevLogIndex+<span class="built_in">len</span>(args.Entries))</span><br><span class="line">        reply.Success = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// other code..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RPC-发送方"><a href="#RPC-发送方" class="headerlink" title="RPC 发送方"></a>RPC 发送方</h3><p>对于日志复制 RPC 发送方来说，需要增加两部分逻辑：</p>
<ol>
<li>每个 RPC 发送前的参数构造</li>
<li>每个 RPC 收到返回值后：<ol>
<li>如果复制成功，则看看是否可以更新 Leader 的 commitIndex （也留到之后实现，TODO，补充小节链接）</li>
<li>如果复制失败，则需要将匹配点回退，继续试探。</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startReplication(term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">				<span class="comment">// other code...</span></span><br><span class="line">            </span><br><span class="line">                <span class="comment">// probe the lower index if the prev log not matched</span></span><br><span class="line">                <span class="keyword">if</span> !reply.Success &#123;</span><br><span class="line">                        idx := rf.nextIndex[peer] - <span class="number">1</span></span><br><span class="line">                        term := rf.log[idx].Term</span><br><span class="line">                        <span class="keyword">for</span> idx &gt; <span class="number">0</span> &amp;&amp; rf.log[idx].Term == term &#123;</span><br><span class="line">                                idx--</span><br><span class="line">                        &#125;</span><br><span class="line">                        rf.nextIndex[peer] = idx + <span class="number">1</span></span><br><span class="line">                        LOG(rf.me, rf.currentTerm, DLog, <span class="string">&quot;Log not matched in %d, Update next=%d&quot;</span>, args.PrevLogIndex, rf.nextIndex[peer])</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// update the match/next index if log appended successfully</span></span><br><span class="line">                rf.matchIndex[peer] = args.PrevLogIndex + <span class="built_in">len</span>(args.Entries)</span><br><span class="line">                rf.nextIndex[peer] = rf.matchIndex[peer] + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> need compute the new commitIndex here, </span></span><br><span class="line">                <span class="comment">// but we leave it to the other chapter</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// other code ..</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                <span class="keyword">if</span> peer == rf.me &#123;</span><br><span class="line">                        <span class="comment">// Don&#x27;t forget to update Leader&#x27;s matchIndex</span></span><br><span class="line">                        rf.matchIndex[peer] = <span class="built_in">len</span>(rf.log) - <span class="number">1</span></span><br><span class="line">                        rf.nextIndex[peer] = <span class="built_in">len</span>(rf.log)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                prevIdx := rf.nextIndex[peer] - <span class="number">1</span></span><br><span class="line">                prevTerm := rf.log[prevIdx].Term</span><br><span class="line">                args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">                        Term:         rf.currentTerm,</span><br><span class="line">                        LeaderId:     rf.me,</span><br><span class="line">                        PrevLogIndex: prevIdx,</span><br><span class="line">                        PrevLogTerm:  prevTerm,</span><br><span class="line">                        Entries:      rf.log[prevIdx+<span class="number">1</span>:],</span><br><span class="line">                        LeaderCommit: rf.commitIndex,</span><br><span class="line">                &#125;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;-&gt; S%d, Send log, Prev=[%d]T%d, Len()=%d&quot;</span>, peer, args.PrevLogIndex, args.PrevLogTerm, <span class="built_in">len</span>(args.Entries))</span><br><span class="line">                <span class="keyword">go</span> replicateToPeer(peer, args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分的最终目的，就是要更新 <code>matchIndex</code>。进而依据所有 Peer 的 <code>matchIndex</code> 来算 <code>commitIndex</code> 。Leader 有了 <code>commitIndex</code> 之后，再将其下发给各个 Follower，指导其各自更新本地 <code>commitIndex</code> 进而 apply。</p>
<p><code>matchIndex</code> 和 <code>nextIndex</code>  是什么时候初始化的？所以，我们要继续补上这两个字段的初始化逻辑。本质上来说，这两个字段是各个 Peer 中日志进度在 Leader 中的一个<strong>视图</strong>（view）。Leader 正是依据此视图来决定给各个 Peer 发送多少日志。也是依据此视图，Leader 可以计算全局的 <code>commitIndex</code>。</p>
<p>因此，该视图只在 Leader 当选的 Term 中有用。故而，我们要在 Leader 一当选时，更新该视图，即 <code>becomeLeaderLocked</code> 中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeLeaderLocked() &#123;</span><br><span class="line">		<span class="comment">// other code...</span></span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                rf.nextIndex[peer] = <span class="built_in">len</span>(rf.log)</span><br><span class="line">                rf.matchIndex[peer] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选举日志比较"><a href="#选举日志比较" class="headerlink" title="选举日志比较"></a>选举日志比较</h2><h3 id="日志新旧比较"><a href="#日志新旧比较" class="headerlink" title="日志新旧比较"></a>日志新旧比较</h3><p> 比较对象是最后一个 LogEntry，<strong>比较规则</strong>是：</p>
<ol>
<li>Term 高者更新</li>
<li>Term 同，Index 大者更新</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> isMoreUpToDateLocked(candidateIndex, candidateTerm <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">        l := <span class="built_in">len</span>(rf.log)</span><br><span class="line">        lastTerm, lastIndex := rf.log[l<span class="number">-1</span>].Term, l<span class="number">-1</span></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;Compare last log, Me: [%d]T%d, Candidate: [%d]T%d&quot;</span>, lastIndex, lastTerm, candidateIndex, candidateTerm)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> lastTerm != candidateTerm &#123;</span><br><span class="line">                <span class="keyword">return</span> lastTerm &gt; candidateTerm</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastIndex &gt; candidateIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增加日志比较"><a href="#增加日志比较" class="headerlink" title="增加日志比较"></a>增加日志比较</h3><p>选举这一块需要增加的逻辑比较简单，只需要：</p>
<ol>
<li>在发送 RPC 构造参数时增加上最后一条日志信息</li>
<li>在接收 RPC 投票前比较日志新旧</li>
</ol>
<p>根据论文图 2 补全 RPC 相关结构体字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RequestVoteArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// Your data here (PartA, PartB).</span></span><br><span class="line">        Term         <span class="type">int</span></span><br><span class="line">        CandidateId  <span class="type">int</span></span><br><span class="line">        LastLogIndex <span class="type">int</span></span><br><span class="line">        LastLogTerm  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送方（Candidate），在发送 RPC 增加构造参数，带上 Candidate 最后一条日志的信息（index 和 term）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startElection(term <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        l := <span class="built_in">len</span>(rf.log)</span><br><span class="line">        <span class="keyword">for</span> peer := <span class="number">0</span>; peer &lt; <span class="built_in">len</span>(rf.peers); peer++ &#123;</span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line">                args := &amp;RequestVoteArgs&#123;</span><br><span class="line">						<span class="comment">// ...</span></span><br><span class="line">                        LastLogIndex: l<span class="number">-1</span>,</span><br><span class="line">                        LastLogTerm:  rf.log[l<span class="number">-1</span>].Term,</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">go</span> askVoteFromPeer(peer, args)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收方（各个 Peer 的回调函数），在对齐 Term，检查完没有投过票之后，进一步比较最后一条日志，看谁的更新。如果本 Peer 比 Candidate 更新，则拒绝投票给 Candidate。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example RequestVote RPC handler.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// check log, only grante vote when the candidates have more up-to-date log</span></span><br><span class="line">        <span class="keyword">if</span> rf.isMoreUpToDateLocked(args.LastLogIndex，args.LastLogTerm) &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DVote, <span class="string">&quot;-&gt; S%d, Reject Vote, S%d&#x27;s log less up-to-date&quot;</span>, args.CandidateId)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="日志应用"><a href="#日志应用" class="headerlink" title="日志应用"></a>日志应用</h2><p>我们需要给 apply 逻辑补上两个字段：</p>
<ol>
<li><strong>commitIndex</strong>：全局日志提交进度</li>
<li><strong>lastApplied</strong>：本 Peer 日志 apply 进度</li>
</ol>
<p>由于我们想在实现时，使用 <code>sync.Cond</code> 唤醒 apply 的工作流，因此需要增加：**<code>applyCond</code>**。</p>
<p>最后，在我们 Raft 实现的设定中，apply 的过程，就是将 applyMsg 通过构造 Peer 时传进来的 channel 返回给应用层。因此还需要保存下这个 <strong>applyCh</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Go object implementing a single Raft peer.</span></span><br><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// commit index and last applied</span></span><br><span class="line">        commitIndex <span class="type">int</span></span><br><span class="line">        lastApplied <span class="type">int</span></span><br><span class="line">        applyCond   *sync.Cond</span><br><span class="line">        applyCh     <span class="keyword">chan</span> ApplyMsg</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加其初始化。<strong>applyCond</strong> 在初始化时，需要关联到一把锁上，这是<code> sync.Cond</code> 的使用要求，之后只有在该锁临界区内才可以进行 <code>Wait()</code> 和 <code>Signal()</code> 的调用。对于我们来说，这把锁自然就是全局的那把大锁：<code>rf.mu</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span></span> *Raft &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        </span><br><span class="line">        rf.applyCh = applyCh</span><br><span class="line">        rf.commitIndex = <span class="number">0</span></span><br><span class="line">        rf.lastApplied = <span class="number">0</span></span><br><span class="line">        rf.applyCond = sync.NewCond(&amp;rf.mu)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    	<span class="keyword">go</span> rf.applyTicker()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Apply-工作流"><a href="#Apply-工作流" class="headerlink" title="Apply 工作流"></a>Apply 工作流</h3><p>Apply 工作流在实现的时候，最重要的就是在给 applyCh 发送 ApplyMsg 时，不要在加锁的情况下进行。因为我们并不知道这个操作会耗时多久（即应用层多久会取走数据），因此不能让其在 apply 的时候持有锁。</p>
<p>于是，我们把 apply 分为三个阶段：</p>
<ol>
<li><strong>阶段一</strong>：构造所有待 apply 的 <code>ApplyMsg</code></li>
<li><strong>阶段二</strong>：遍历这些 msgs，进行 apply</li>
<li><strong>阶段三</strong>：更新 <code>lastApplied</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> applyTicker() &#123;</span><br><span class="line">        <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                rf.applyCond.Wait()</span><br><span class="line">				</span><br><span class="line">                entries := <span class="built_in">make</span>([]LogEntry, <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// should start from rf.lastApplied+1 instead of rf.lastApplied</span></span><br><span class="line">                <span class="keyword">for</span> i := rf.lastApplied + <span class="number">1</span>; i &lt;= rf.commitIndex; i++ &#123;</span><br><span class="line">                        entries = <span class="built_in">append</span>(entries, rf.log[i])</span><br><span class="line">                &#125;</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> i, entry := <span class="keyword">range</span> entries &#123;</span><br><span class="line">                        rf.applyCh &lt;- ApplyMsg&#123;</span><br><span class="line">                                CommandValid: entry.CommandValid,</span><br><span class="line">                                Command:      entry.Command,</span><br><span class="line">                                CommandIndex: rf.lastApplied + <span class="number">1</span> + i,</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DApply, <span class="string">&quot;Apply log for [%d, %d]&quot;</span>, rf.lastApplied+<span class="number">1</span>, rf.lastApplied+<span class="built_in">len</span>(entries))</span><br><span class="line">                rf.lastApplied += <span class="built_in">len</span>(entries)</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要我们保证全局就只有这一个 apply 的地方，那我们这样分成三个部分问题就不大。尤其是需要注意，当后面增加  snapshot  apply 的逻辑时，也要放到该函数里。</p>
<h3 id="Leader-CommitIndex-更新"><a href="#Leader-CommitIndex-更新" class="headerlink" title="Leader CommitIndex 更新"></a>Leader CommitIndex 更新</h3><p>在 Leader 给其他 Peer <code>AppendEntries</code> 成功后，会更新 <code>rf.matchIndex</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">replicateToPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        majorityMatched := rf.getMajorityIndexLocked()</span><br><span class="line">        <span class="keyword">if</span> majorityMatched &gt; rf.commitIndex &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DApply, <span class="string">&quot;Leader update the commit index %d-&gt;%d&quot;</span>, rf.commitIndex, majorityMatched)</span><br><span class="line">                rf.commitIndex = majorityMatched</span><br><span class="line">                rf.applyCond.Signal()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每次更新 <code>rf.matchIndex</code> 后，依据此全局匹配点视图，我们可以算出多数 Peer 的匹配点，进而更新 Leader 的 <code>CommitIndex</code>。我们可以使用<strong>排序后找中位数</strong>的方法来计算。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> getMajorityIndexLocked() <span class="type">int</span> &#123;</span><br><span class="line">        <span class="comment">// TODO(spw): may could be avoid copying</span></span><br><span class="line">        tmpIndexes := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(rf.matchIndex))</span><br><span class="line">        <span class="built_in">copy</span>(tmpIndexes, rf.matchIndex)</span><br><span class="line">        sort.Ints(sort.IntSlice(tmpIndexes))</span><br><span class="line">        majorityIdx := (<span class="built_in">len</span>(tmpIndexes) - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        LOG(rf.me, rf.currentTerm, DDebug, <span class="string">&quot;Match index after sort: %v, majority[%d]=%d&quot;</span>, tmpIndexes, majorityIdx, tmpIndexes[majorityIdx])</span><br><span class="line">        <span class="keyword">return</span> tmpIndexes[majorityIdx] <span class="comment">// min -&gt; max</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于排序会改变原数组，因此要把 matchIndex 复制一份再进行排序，</p>
<p><strong>如果 <code>commitIndex</code> 更新后，则唤醒 apply 工作流，提醒可以 apply 新的日志到本地了。</strong></p>
<h3 id="Follower-CommitIndex-更新"><a href="#Follower-CommitIndex-更新" class="headerlink" title="Follower CommitIndex 更新"></a>Follower CommitIndex 更新</h3><p>在 Leader CommitIndex 更新后，会通过下一次的 <code>AppendEntries</code> 的 RPC 参数发送给每个 Follower。则首先，要根据论文图 2，在 <code>AppendEntriesArgs</code> 中增加 <code>LeaderCommit</code> 参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">        Term     <span class="type">int</span></span><br><span class="line">        LeaderId <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        PrevLogIndex <span class="type">int</span></span><br><span class="line">        PrevLogTerm  <span class="type">int</span></span><br><span class="line">        Entries      []LogEntry</span><br><span class="line"></span><br><span class="line">        LeaderCommit <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 Follower 通过 AppendEntries 的回调函数收到 Leader 发来的 <code>LeaderCommit</code>，来更新本地的 <code>CommitIndex</code>，进而驱动 Apply 工作流开始干活。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// update the commit index if needed and indicate the apply loop to apply</span></span><br><span class="line">        <span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">                LOG(rf.me, rf.currentTerm, DApply, <span class="string">&quot;Follower update the commit index %d-&gt;%d&quot;</span>, rf.commitIndex, args.LeaderCommit)</span><br><span class="line">                rf.commitIndex = args.LeaderCommit</span><br><span class="line">                <span class="keyword">if</span> rf.commitIndex &gt;= <span class="built_in">len</span>(rf.log) &#123;</span><br><span class="line">                    rf.commitIndex = <span class="built_in">len</span>(rf.log) - <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                rf.applyCond.Signal()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面 Peer 收到 Leader 发来的日志同步请求处理逻辑中，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.Term &gt;= rf.currentTerm &#123;</span><br><span class="line">            rf.becomeFollowerLocked(args.Term)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于大于的情况，容易理解，论文中就这么写的。为什么相同任期也要变为 Follower？</p>
<p>对于相同任期来说，可以分情况考虑：</p>
<ol>
<li>首先他不可能是 leader，因为一个任期最多只会选出一个 leader</li>
<li>如果他是 Candidate，收到 Leader 的日志同步请求，得变 Follower</li>
<li>如果本来就是 Follower 就无所谓了</li>
</ol>
<h2 id="实现要点-1"><a href="#实现要点-1" class="headerlink" title="实现要点"></a>实现要点</h2><h3 id="Context-检查"><a href="#Context-检查" class="headerlink" title="Context 检查"></a>Context 检查</h3><p>需要 Context 检查的主要有四个地方：</p>
<ol>
<li>startReplication 前，检查自己仍然是给定 term 的 Leader</li>
<li>replicateToPeer 处理 reply 时，检查自己仍然是给定 term 的 Leader</li>
<li>startElection 前，检查自己仍然是给定 term 的 Candidate</li>
<li>askVoteFromPeer 处理 reply 时，检查自己仍然是给定 term 的 Candidate</li>
</ol>
<p>由于我们 replication 和 election 实现的对称性，可以发现前两个和后两个是对称的，因此很好记忆。</p>
<h3 id="Start-实现"><a href="#Start-实现" class="headerlink" title="Start 实现"></a>Start 实现</h3><p>只有正确实现了 Start，tester 才能通过 Start 给 Leader 本地追加日志。进而通过 Leader 的 AppendEntries RPC 将日志分发给所有 Follower，然后在发现大多数 Peer 在本地追加该日志之后，指示每个 Peer Apply 该日志。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Start(command <span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rf.role != Leader &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log, LogEntry&#123;</span><br><span class="line">                CommandValid: <span class="literal">true</span>,</span><br><span class="line">                Command:      command,</span><br><span class="line">                Term:         rf.currentTerm,</span><br><span class="line">        &#125;)</span><br><span class="line">        LOG(rf.me, rf.currentTerm, DLeader, <span class="string">&quot;Leader accept log [%d]T%d&quot;</span>, <span class="built_in">len</span>(rf.log)<span class="number">-1</span>, rf.currentTerm)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(rf.log) - <span class="number">1</span>, rf.currentTerm, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试时遇到的小问题，<code>/usr/bin/env: ‘python3\r’: No such file or directory</code> ，这是由于换行符导致的，解决方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dos2unix ../tools/dstest</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">ytf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/02/06/raft/">http://example.com/2024/02/06/raft/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">ytfの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Mit6-5840/">Mit6.5840</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/01/25/MapReduce/" title="MapReduce"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MapReduce</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ytf</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PartA-%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE"><span class="toc-number">1.</span> <span class="toc-text">PartA 领导选举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.</span> <span class="toc-text">状态转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E9%80%BB%E8%BE%91"><span class="toc-number">1.2.</span> <span class="toc-text">选举逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E4%B8%BE-loop"><span class="toc-number">1.2.1.</span> <span class="toc-text">选举 loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%BD%AE%E9%80%89%E4%B8%BE"><span class="toc-number">1.2.2.</span> <span class="toc-text">单轮选举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A3%80%E6%9F%A5"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">上下文检查</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%AC%A1-RPC"><span class="toc-number">1.2.3.</span> <span class="toc-text">单次 RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90%E4%BB%BB%E6%9C%9F"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">对齐任期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">回调函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E9%80%BB%E8%BE%91"><span class="toc-number">1.3.</span> <span class="toc-text">心跳逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3-Loop"><span class="toc-number">1.3.1.</span> <span class="toc-text">心跳 Loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%BD%AE%E5%BF%83%E8%B7%B3"><span class="toc-number">1.3.2.</span> <span class="toc-text">单轮心跳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%AC%A1-RPC-1"><span class="toc-number">1.3.3.</span> <span class="toc-text">单次 RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-1"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">回调函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%A6%81%E7%82%B9"><span class="toc-number">1.4.</span> <span class="toc-text">实现要点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PartB-%E6%97%A5%E5%BF%97%E5%90%8C%E6%AD%A5"><span class="toc-number">2.</span> <span class="toc-text">PartB 日志同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">日志复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%8C%E5%96%84"><span class="toc-number">2.1.1.</span> <span class="toc-text">结构体完善</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AppendEntries-RPC-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">AppendEntries RPC 结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Raft-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">Raft 结构体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PC-%E6%8E%A5%E6%94%B6%E6%96%B9"><span class="toc-number">2.1.2.</span> <span class="toc-text">PC 接收方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC-%E5%8F%91%E9%80%81%E6%96%B9"><span class="toc-number">2.1.3.</span> <span class="toc-text">RPC 发送方</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E6%97%A5%E5%BF%97%E6%AF%94%E8%BE%83"><span class="toc-number">2.2.</span> <span class="toc-text">选举日志比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%96%B0%E6%97%A7%E6%AF%94%E8%BE%83"><span class="toc-number">2.2.1.</span> <span class="toc-text">日志新旧比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E6%97%A5%E5%BF%97%E6%AF%94%E8%BE%83"><span class="toc-number">2.2.2.</span> <span class="toc-text">增加日志比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%BA%94%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">日志应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Apply-%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">2.3.1.</span> <span class="toc-text">Apply 工作流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leader-CommitIndex-%E6%9B%B4%E6%96%B0"><span class="toc-number">2.3.2.</span> <span class="toc-text">Leader CommitIndex 更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Follower-CommitIndex-%E6%9B%B4%E6%96%B0"><span class="toc-number">2.3.3.</span> <span class="toc-text">Follower CommitIndex 更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%A6%81%E7%82%B9-1"><span class="toc-number">2.4.</span> <span class="toc-text">实现要点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Context-%E6%A3%80%E6%9F%A5"><span class="toc-number">2.4.1.</span> <span class="toc-text">Context 检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Start-%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.2.</span> <span class="toc-text">Start 实现</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/06/raft/" title="Raft">Raft</a><time datetime="2024-02-06T04:54:51.000Z" title="发表于 2024-02-06 12:54:51">2024-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/25/MapReduce/" title="MapReduce">MapReduce</a><time datetime="2024-01-25T11:47:16.000Z" title="发表于 2024-01-25 19:47:16">2024-01-25</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2024/01/23/hello-world/" title="Hello World">Hello World</a><time datetime="2024-01-23T02:28:46.887Z" title="发表于 2024-01-23 10:28:46">2024-01-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By ytf</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>