<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>shardkv | ytfの博客</title><meta name="author" content="ytf"><meta name="copyright" content="ytf"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基于 multi raft 的 shardkv 概述大致架构这个部分需要完成的分片的分布式 KV 存储系统由两个主要的部分组成。首先是复制组（Replica Group），它指的是处理一个或多个 shard 的 KV 服务，通常是由一个 Raft 集群组成的，所以一个完整的分片分布式 KV 系统中一般存在多个 Replica Group，每个 Group 负责一部分 shard 的读写请求和数据存">
<meta property="og:type" content="article">
<meta property="og:title" content="shardkv">
<meta property="og:url" content="http://example.com/2024/02/29/shardkv/index.html">
<meta property="og:site_name" content="ytfの博客">
<meta property="og:description" content="基于 multi raft 的 shardkv 概述大致架构这个部分需要完成的分片的分布式 KV 存储系统由两个主要的部分组成。首先是复制组（Replica Group），它指的是处理一个或多个 shard 的 KV 服务，通常是由一个 Raft 集群组成的，所以一个完整的分片分布式 KV 系统中一般存在多个 Replica Group，每个 Group 负责一部分 shard 的读写请求和数据存">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://th.bing.com/th/id/OIP.TcbJ6d599uboFBVqWY1wKQHaEK?rs=1&pid=ImgDetMain">
<meta property="article:published_time" content="2024-02-29T02:39:32.000Z">
<meta property="article:modified_time" content="2024-03-01T08:31:13.663Z">
<meta property="article:author" content="ytf">
<meta property="article:tag" content="Mit6.5840">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://th.bing.com/th/id/OIP.TcbJ6d599uboFBVqWY1wKQHaEK?rs=1&pid=ImgDetMain"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/02/29/shardkv/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'shardkv',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-03-01 16:31:13'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://pic.bizhi360.com/bbpic/44/11444.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="ytfの博客"><img class="site-icon" src="https://www.freeimg.cn/i/2024/02/29/65e066f56949c.jpg"/><span class="site-name">ytfの博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">shardkv</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-29T02:39:32.000Z" title="发表于 2024-02-29 10:39:32">2024-02-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-01T08:31:13.663Z" title="更新于 2024-03-01 16:31:13">2024-03-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="shardkv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基于-multi-raft-的-shardkv-概述"><a href="#基于-multi-raft-的-shardkv-概述" class="headerlink" title="基于 multi raft 的 shardkv 概述"></a>基于 multi raft 的 shardkv 概述</h1><h2 id="大致架构"><a href="#大致架构" class="headerlink" title="大致架构"></a>大致架构</h2><p>这个部分需要完成的分片的分布式 KV 存储系统由两个主要的部分组成。首先是复制组（Replica Group），它指的是处理一个或多个 shard 的 KV 服务，通常是由一个 Raft 集群组成的，所以一个完整的分片分布式 KV 系统中一般存在多个 Replica Group，每个 Group 负责一部分 shard 的读写请求和数据存储，多个 Replica Group 的组合又叫做 <code>multi raft</code>。</p>
<p><img src="https://www.freeimg.cn/i/2024/02/29/65dfef19c41fe.png" alt="img"></p>
<p>第二个组成部分是 “shard controller”，它主要是存储系统元数据，一般是一些配置信息，例如每个 Group 应该负责哪些 shard，这个配置信息是有可能发生变化的。客户端首先会从 shard controller 获取请求 key 所属的 Group，并且 Group 也会从 shard controller 中获取它应该负责哪些 shard。shard controller 也一般是会保证高可用，因为如果 shard controller 发生了单点故障，那么整个分布式 KV 系统就不可用了，因此 shard controller 也会使用 raft 进行状态同步。</p>
<p>我们实现的分片分布式系统需要能够将 shard 在不同的 Group 中进行迁移</p>
<ul>
<li>一个原因是负载均衡，比如一个 Group 有可能比其他的负责了更多 shard 的请求，导致其自身压力较大，因此我们需要将较多 shard 的 Group 移动到其他较少 shard 的 Group 中，让各个 Group 之间能够达到一个相对的均衡状态。</li>
<li>另一个原因是集群的变更，例如一个旧的 Group 有可能因为发生了故障而退出了整个集群，那么它负责的 shard 就应该转移到其他的 Group 中。还有一种情况是集群中加入了新的 Group，那么也需要将一些 shard 移动到这个新的 Group 中。</li>
</ul>
<blockquote>
<p>这一部分最主要的难点和挑战在于处理配置的变更，即 shard 到 Group 的映射关系。在一个 Group 的内部，所有 Group 内部的成员都必须要在处理请求和配置变更同时发生时保持一致。</p>
<p>例如，如果一个 Group 收到了配置变更的消息，指示它不能再负责一个 shard 了，而如果此时刚好有一个 Put 请求到这个 shard 上，那么此时 Group 内所有的副本都应该就 Put 请求应该是在配置变更之前还是之后生效而保持一致。如果是在之前生效的话，那么这个 Put 请求应该生效，并且 shard 新所属的 Group 能够看到这个 Put 的值，如果是之后生效的话，那么 Put 请求不应该成功，客户端需要向 shard 新的所属的 Group 重试请求。</p>
<p><strong>这种情况的一种推荐的解决方案是将配置变更的请求也传到 raft 模块中进行状态同步，需要保证一个 shard 在同一时刻，只能被一个 Group 所负责。</strong></p>
<p>配置变更也需要各个 Group 之间进行数据传输，比如一个 shard 在配置变更期间的所有权转移到了另一个 Group 中，那么一个 Group 就需要从原来的 Group 中获取这个 shard 的所有数据。</p>
</blockquote>
<h2 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h2><h3 id="shardctrler"><a href="#shardctrler" class="headerlink" title="shardctrler"></a>shardctrler</h3><p>分片分布式 KV 系统的代码会像其架构一样，分为两个部分，一是 shard controller，这部分代码在目录 <code>shardctrler</code> 中。</p>
<p>客户端以 Clerk 结构体进行维护：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Clerk <span class="keyword">struct</span> &#123;</span><br><span class="line">    servers []*labrpc.ClientEnd</span><br><span class="line">    <span class="comment">// Your data here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端这边有四个基础的方法 <code>Query、Join、Leave、Move</code>，表示集群配置的变更，shardctrler 需要处理这个变更，然后将配置信息存储起来。</p>
<h3 id="shardkv"><a href="#shardkv" class="headerlink" title="shardkv"></a>shardkv</h3><p>另一个组成部分是在目录 <code>shardkv</code> 中，这里主要处理的是分布式 KV 的具体逻辑，客户端同样以 Clerk 结构体进行表示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Clerk <span class="keyword">struct</span> &#123;</span><br><span class="line">    sm       *shardctrler.Clerk</span><br><span class="line">    config   shardctrler.Config</span><br><span class="line">    make_end <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> *labrpc.ClientEnd</span><br><span class="line">    <span class="comment">// You will have to modify this struct.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 Clerk 相较于之前的多了一些额外的信息，包括 shardctrler、配置信息 Config 等。</p>
<p>客户端这边和之前一样，有三个基础的数据操作的方法 Get、Put、Append。</p>
<p>服务端的代码在 server.go 中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ShardKV <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu           sync.Mutex</span><br><span class="line">    me           <span class="type">int</span></span><br><span class="line">    rf           *raft.Raft</span><br><span class="line">    applyCh      <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line">    make_end     <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> *labrpc.ClientEnd</span><br><span class="line">    gid          <span class="type">int</span></span><br><span class="line">    ctrlers      []*labrpc.ClientEnd</span><br><span class="line">    maxraftstate <span class="type">int</span> <span class="comment">// snapshot if log grows this big</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Your definitions here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="shard-controller"><a href="#shard-controller" class="headerlink" title="shard controller"></a>shard controller</h1><h2 id="shard-controller-的-Client-端处理"><a href="#shard-controller-的-Client-端处理" class="headerlink" title="shard controller 的 Client 端处理"></a>shard controller 的 Client 端处理</h2><p>Shardctrler 存储的配置信息，实际上是多个带编号的配置组合而成的数组，每个配置都有一个唯一的编号（数组下标），配置中存储的是 shard id 到 Group id 的映射关系，以及 Group id 对应的 KVServer。</p>
<p>每次只要有了新的配置产生，就会向数组中新增一个元素。KV 客户端或者服务端可以向 shardctrler 获取最新的或者旧的配置信息。</p>
<p>Shardctrler 存储的配置信息，实际上是多个带编号的配置组合而成的数组，每个配置都有一个唯一的编号（数组下标），配置中存储的是 shard id 到 Group id 的映射关系，以及 Group id 对应的 KVServer。</p>
<p>每次只要有了新的配置产生，就会向数组中新增一个元素。KV 客户端或者服务端可以向 shardctrler 获取最新的或者旧的配置信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ShardCtrler <span class="keyword">struct</span> &#123;</span><br><span class="line">   mu      sync.Mutex</span><br><span class="line">   me      <span class="type">int</span></span><br><span class="line">   rf      *raft.Raft</span><br><span class="line">   applyCh <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Your data here.</span></span><br><span class="line"></span><br><span class="line">   configs []Config <span class="comment">// indexed by config num</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A configuration -- an assignment of shards to groups.</span></span><br><span class="line"><span class="comment">// Please don&#x27;t change this.</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">   Num    <span class="type">int</span>              <span class="comment">// config number</span></span><br><span class="line">   Shards [NShards]<span class="type">int</span>     <span class="comment">// shard -&gt; gid</span></span><br><span class="line">   Groups <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">string</span> <span class="comment">// gid -&gt; servers[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 shardctrler 的客户端中，提供的方法主要是对配置进行获取，以及配置变更的处理。目前有四个方法：Query、Leave、Join、Move。</p>
<blockquote>
<p>我们在向客户端发送请求的时候，一是需要注意如果发生了一些错误，例如得到了 ErrWrongLeader 或 ErrTimeout 错误，说明当前节点并不是 Leader 或者发生了其他的错误，我们就需要选择另一个节点重试请求。</p>
<p>二是我们仍然需要像之前一样处理重复请求，保证线性一致性，处理的方法和之前一样，给每个客户端的请求都赋予一个维护的标识符，然后在 server 端进行去重。（clientId+seqId)即可</p>
</blockquote>
<h3 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h3><p><code>Join</code> 方法是添加新的 Group，它的参数是一个 map，存储了 Replica Group 的唯一标识 GID 到服务节点名字列表的映射关系。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Join(servers <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">string</span>) &#123;</span><br><span class="line">    args := &amp;JoinArgs&#123;ClientId: ck.clientId, SeqId: ck.seqId&#125;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    args.Servers = servers</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// try each known server.</span></span><br><span class="line">        <span class="keyword">var</span> reply JoinReply</span><br><span class="line">        ok := ck.servers[ck.leaderId].Call(<span class="string">&quot;ShardCtrler.Join&quot;</span>, args, &amp;reply)</span><br><span class="line">        <span class="keyword">if</span> !ok || reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line">            ck.leaderId = (ck.leaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        ck.seqId++</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Leave"><a href="#Leave" class="headerlink" title="Leave"></a>Leave</h3><p><code>Leave</code> 方法的参数是一组集群中的 Group ID，表示这些 Group 退出了分布式集群。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Leave(gids []<span class="type">int</span>) &#123;</span><br><span class="line">	args := &amp;LeaveArgs&#123;ClientId: ck.clientId, SeqId: ck.seqId&#125;</span><br><span class="line">	<span class="comment">// Your code here.</span></span><br><span class="line">	args.GIDs = gids</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// try each known server.</span></span><br><span class="line">		<span class="keyword">var</span> reply LeaveReply</span><br><span class="line">		ok := ck.servers[ck.leaderId].Call(<span class="string">&quot;ShardCtrler.Leave&quot;</span>, args, &amp;reply)</span><br><span class="line">		<span class="keyword">if</span> !ok || reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line">			ck.leaderId = (ck.leaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		ck.seqId++</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Move"><a href="#Move" class="headerlink" title="Move"></a>Move</h3><p><code>Move</code> 方法的参数是一个 shard 编号和一个 Group ID。主要是用于将一个 shard 移动到指定的 Group 中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Move(shard <span class="type">int</span>, gid <span class="type">int</span>) &#123;</span><br><span class="line">	args := &amp;MoveArgs&#123;ClientId: ck.clientId, SeqId: ck.seqId&#125;</span><br><span class="line">	<span class="comment">// Your code here.</span></span><br><span class="line">	args.Shard = shard</span><br><span class="line">	args.GID = gid</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// try each known server.</span></span><br><span class="line">		<span class="keyword">var</span> reply MoveReply</span><br><span class="line">		ok := ck.servers[ck.leaderId].Call(<span class="string">&quot;ShardCtrler.Move&quot;</span>, args, &amp;reply)</span><br><span class="line">		<span class="keyword">if</span> !ok || reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line">			ck.leaderId = (ck.leaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		ck.seqId++</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><p><code>Query</code> 方法的参数是一个配置编号，shardctrler 依赖于这个带编号的配置，如果编号是 -1，或者大于已知的最大的编号，那么应该返回最近的一个配置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Query(num <span class="type">int</span>) Config &#123;</span><br><span class="line">    args := &amp;QueryArgs&#123;&#125;</span><br><span class="line">    args.Num = num</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    args.Num = num</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// try each known server.</span></span><br><span class="line">        <span class="keyword">var</span> reply QueryReply</span><br><span class="line">        ok := ck.servers[ck.leaderId].Call(<span class="string">&quot;ShardCtrler.Query&quot;</span>, args, &amp;reply)</span><br><span class="line">        <span class="keyword">if</span> !ok || reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line">            ck.leaderId = (ck.leaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reply.Config</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="shard-controller-的-Server-端处理"><a href="#shard-controller-的-Server-端处理" class="headerlink" title="shard controller 的 Server 端处理"></a>shard controller 的 Server 端处理</h2><p>其实 Server 这边的处理和前一个部分我们实现的分布式 KV 的 Server 非常类似，逻辑基本上是差不多的。</p>
<p>我们依然需要维护状态机、通知 channel、去重的哈希表，在前面的概述中提到了，由于 shardctrler 是存储的一些配置信息，并不会存储用户数据，所以数据相对来说是比较少的，因此我们可以不用去实现分布式 KV 中的 snapshot 机制。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ShardCtrler <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu      sync.Mutex</span><br><span class="line">    me      <span class="type">int</span></span><br><span class="line">    rf      *raft.Raft</span><br><span class="line">    applyCh <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Your data here.</span></span><br><span class="line"></span><br><span class="line">    configs []Config <span class="comment">// indexed by config num</span></span><br><span class="line"></span><br><span class="line">    dead           <span class="type">int32</span> <span class="comment">// set by Kill()</span></span><br><span class="line">    lastApplied    <span class="type">int</span></span><br><span class="line">    stateMachine   *CtrlerStateMachine</span><br><span class="line">    notifyChans    <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">chan</span> *OpReply</span><br><span class="line">    duplicateTable <span class="keyword">map</span>[<span class="type">int64</span>]LastOperationInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们接收客户端的四种请求 Query、Join、Leave、Move，然后将其通过 raft 模块进行各个节点之间的状态同步。</p>
<p>然后我们在后台的 apply 线程中处理 raft 已经 commit 的数据，主要是将操作应用到状态机中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> applyLogToStateMachine(op Op) *OpRelpy &#123;</span><br><span class="line">    <span class="keyword">var</span> err Err</span><br><span class="line">    <span class="keyword">var</span> config Config</span><br><span class="line">    <span class="keyword">switch</span> op.OpType &#123;</span><br><span class="line">        <span class="keyword">case</span> OpJoin:</span><br><span class="line">        err = sc.stateMachine.Join(op.Servers)</span><br><span class="line">        <span class="keyword">case</span> OpLeave:</span><br><span class="line">        err = sc.stateMachine.Leave(op.GIDs)</span><br><span class="line">        <span class="keyword">case</span> OpMove:</span><br><span class="line">        err = sc.stateMachine.Move(op.Shard, op.GID)</span><br><span class="line">        <span class="keyword">case</span> OpQuery:</span><br><span class="line">        config, err = sc.stateMachine.Query(op.Num)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;OpRelpy&#123;ControllerConfig: config, Err: err&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 Op 结构体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Op <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Your definitions here.</span></span><br><span class="line">    <span class="comment">// Field names must start with capital letters,</span></span><br><span class="line">    <span class="comment">// otherwise RPC will break.</span></span><br><span class="line">    OpType   OperationType</span><br><span class="line">    ClientId <span class="type">int64</span></span><br><span class="line">    SeqId    <span class="type">int64</span></span><br><span class="line">    Servers  <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">string</span> <span class="comment">// new GID -&gt; servers mappings -- for Join</span></span><br><span class="line">    GIDs     []<span class="type">int</span>            <span class="comment">// -- for Leave</span></span><br><span class="line">    Shard    <span class="type">int</span>              <span class="comment">// -- for Move</span></span><br><span class="line">    GID      <span class="type">int</span>              <span class="comment">// -- for Move</span></span><br><span class="line">    Num      <span class="type">int</span>              <span class="comment">// desired config number -- for Query</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于四种请求的逻辑都有相同之处，考虑将他们提取为一个公共方法：</p>
<h3 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> command(args Op, reply *OpReply) &#123;</span><br><span class="line">    <span class="comment">// 判断请求是否重复</span></span><br><span class="line">    sc.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> args.OpType != OpQuery &amp;&amp; sc.requestDuplicated(args.ClientId, args.SeqId) &#123;</span><br><span class="line">        <span class="comment">// 如果是重复请求 直接返回结果</span></span><br><span class="line">        opReply := sc.duplicateTable[args.ClientId].Reply</span><br><span class="line">        reply.Err = opReply.Err</span><br><span class="line">        sc.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    sc.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 raft，将请求存储到 raft 日志中并进行同步</span></span><br><span class="line">    index, _, isLeader := sc.rf.Start(args)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是 Leader 的话，直接返回错误</span></span><br><span class="line">    <span class="keyword">if</span> !isLeader &#123;</span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待结果</span></span><br><span class="line">    sc.mu.Lock()</span><br><span class="line">    notifyCh := sc.getNotifyChannel(index)</span><br><span class="line">    sc.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> result := &lt;-notifyCh:</span><br><span class="line">        reply.ControllerConfig = result.ControllerConfig</span><br><span class="line">        reply.Err = result.Err</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(ClientRequestTimeout):</span><br><span class="line">        reply.Err = ErrTimeout</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除通知的 channel</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sc.mu.Lock()</span><br><span class="line">        sc.removeNotifyChannel(index)</span><br><span class="line">        sc.mu.Unlock()</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Join-1"><a href="#Join-1" class="headerlink" title="Join"></a>Join</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> Join(args *JoinArgs, reply *JoinReply) &#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    <span class="keyword">var</span> opReply OpReply</span><br><span class="line">    sc.command(Op&#123;</span><br><span class="line">       OpType:   OpJoin,</span><br><span class="line">       ClientId: args.ClientId,</span><br><span class="line">       SeqId:    args.SeqId,</span><br><span class="line">       Servers:  args.Servers,</span><br><span class="line">    &#125;, &amp;opReply)</span><br><span class="line"></span><br><span class="line">    reply.Err = opReply.Err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Leave-1"><a href="#Leave-1" class="headerlink" title="Leave"></a>Leave</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> Leave(args *LeaveArgs, reply *LeaveReply) &#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    <span class="keyword">var</span> opReply OpReply</span><br><span class="line">    sc.command(Op&#123;</span><br><span class="line">       OpType:   OpLeave,</span><br><span class="line">       ClientId: args.ClientId,</span><br><span class="line">       SeqId:    args.SeqId,</span><br><span class="line">       GIDs:     args.GIDs,</span><br><span class="line">    &#125;, &amp;opReply)</span><br><span class="line"></span><br><span class="line">    reply.Err = opReply.Err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Move-1"><a href="#Move-1" class="headerlink" title="Move"></a>Move</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> Move(args *MoveArgs, reply *MoveReply) &#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    <span class="keyword">var</span> opReply OpReply</span><br><span class="line">    sc.command(Op&#123;</span><br><span class="line">       OpType:   OpMove,</span><br><span class="line">       ClientId: args.ClientId,</span><br><span class="line">       SeqId:    args.SeqId,</span><br><span class="line">       Shard:    args.Shard,</span><br><span class="line">       GID:      args.GID,</span><br><span class="line">    &#125;, &amp;opReply)</span><br><span class="line"></span><br><span class="line">    reply.Err = opReply.Err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Query-1"><a href="#Query-1" class="headerlink" title="Query"></a>Query</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> Query(args *QueryArgs, reply *QueryReply) &#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    <span class="keyword">var</span> opReply OpReply</span><br><span class="line">    sc.command(Op&#123;</span><br><span class="line">       OpType: OpQuery,</span><br><span class="line">       Num:    args.Num,</span><br><span class="line">    &#125;, &amp;opReply)</span><br><span class="line"></span><br><span class="line">    reply.Config = opReply.ControllerConfig</span><br><span class="line">    reply.Err = opReply.Err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="applyTask"><a href="#applyTask" class="headerlink" title="applyTask"></a>applyTask</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/ 处理 apply 任务</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> applyTask() &#123;</span><br><span class="line">    <span class="keyword">for</span> !sc.killed() &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> message := &lt;-sc.applyCh:</span><br><span class="line">            <span class="keyword">if</span> message.CommandValid &#123;</span><br><span class="line">                sc.mu.Lock()</span><br><span class="line">                <span class="comment">// 如果是已经处理过的消息则直接忽略</span></span><br><span class="line">                <span class="keyword">if</span> message.CommandIndex &lt;= sc.lastApplied &#123;</span><br><span class="line">                    sc.mu.Unlock()</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                sc.lastApplied = message.CommandIndex</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 取出用户的操作信息</span></span><br><span class="line">                op := message.Command.(Op)</span><br><span class="line">                <span class="keyword">var</span> opReply *OpReply</span><br><span class="line">                <span class="keyword">if</span> op.OpType != OpQuery &amp;&amp; sc.requestDuplicated(op.ClientId, op.SeqId) &#123;</span><br><span class="line">                    opReply = sc.duplicateTable[op.ClientId].Reply</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 将操作应用状态机中</span></span><br><span class="line">                    opReply = sc.applyLogToStateMachine(op)</span><br><span class="line">                    <span class="keyword">if</span> op.OpType != OpQuery &#123;</span><br><span class="line">                        sc.duplicateTable[op.ClientId] = LastOperationInfo&#123;</span><br><span class="line">                            SeqId: op.SeqId,</span><br><span class="line">                            Reply: opReply,</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将结果发送回去</span></span><br><span class="line">                <span class="keyword">if</span> _, isLeader := sc.rf.GetState(); isLeader &#123;</span><br><span class="line">                    notifyCh := sc.getNotifyChannel(message.CommandIndex)</span><br><span class="line">                    notifyCh &lt;- opReply</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                sc.mu.Unlock()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="shard-controller-的状态机处理"><a href="#shard-controller-的状态机处理" class="headerlink" title="shard controller 的状态机处理"></a>shard controller 的状态机处理</h2><p>当 raft 模块状态同步完成之后，节点会发送已经 commit 的日志，我们就会在后台常驻的 apply 线程中进行处理，主要是将用户的操作持久化到状态机中。</p>
<p>前面其实提到了我们有四个客户端的方法，分别是 <code>Query、Join、Leave、Move</code>，实际上状态机的处理，就是对这几种方法进行处理，将处理完成之后的配置存储起来，供外部调用，接下来就依次看看这几个方法的大致处理逻辑。</p>
<h3 id="Query-2"><a href="#Query-2" class="headerlink" title="Query"></a>Query</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CtrlerStateMachine <span class="keyword">struct</span> &#123;</span><br><span class="line">   Configs []Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Query</code> 的逻辑比较简单，是通过配置编号 num 进行查询，我们会在状态机中维护一个配置数组，num 其实就是数组的下标，所以能够直接获取到下标对应的配置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(csm *CtrlerStateMachine)</span></span> Query(num <span class="type">int</span>) (Config, Err) &#123;</span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">0</span> || num &gt;= <span class="built_in">len</span>(csm.Configs) &#123;</span><br><span class="line">        <span class="keyword">return</span> csm.Configs[<span class="built_in">len</span>(csm.Configs)<span class="number">-1</span>], OK</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> csm.Configs[num], OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Join-2"><a href="#Join-2" class="headerlink" title="Join"></a>Join</h3><p><code>Join</code> 主要是添加一个 Group 到集群中，我们需要处理添加完成之后的负载均衡问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Join 加入新的复制组，需要处理加入后的负载均衡问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(csm *CtrlerStateMachine)</span></span> Join(groups <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">string</span>) Err &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们已经知道了 Config 的具体内容，主要包含配置编号 Num、shard 到 gid 的映射、gid 及其对应的节点信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Config A configuration -- an assignment of shards to groups.</span></span><br><span class="line"><span class="comment">// Please don&#x27;t change this.</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">   Num    <span class="type">int</span>              <span class="comment">// config number</span></span><br><span class="line">   Shards [NShards]<span class="type">int</span>     <span class="comment">// shard -&gt; gid</span></span><br><span class="line">   Groups <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">string</span> <span class="comment">// gid -&gt; servers[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当新添加 Group 的时候，我们这里的参数是 Groups，表示有可能是多个 Group 加入进来。</p>
<p>首先我们需要遍历传递进来的 Group，将其加入到 Config 的 <code>Groups</code> 中，这里就需要注意我们前面提到过的问题，那就是加入之后，shard 应该怎么处理。</p>
<p>假设这样一种情况，我们有 10 个 shard 和 3 个 Group，其在 Config 中的对应关系如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Config.Shards 数组:</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> -- shard id</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> -- group id</span><br></pre></td></tr></table></figure>

<p>现在有了一个新的 Group ID 为 4 加入进来，我们就需要重新处理 shard 到 Group 的关系，因为不能让新加入的 Group 处于空闲状态，而应该分担一部分 shard，让整个集群重新达到平衡。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Config.Shards 数组:</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>            -- shard id</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span>          -- group id</span><br></pre></td></tr></table></figure>

<p>我们的做法简单来说是从拥有最多 shard 的 Group 中取出一个 shard，将其分配给最少 shard 的那个 Group，如果最多和最少的 shard 的差值小于等于 1，那么说明就已经达到了平衡，否则的话就按照同样的方法一直重复移动 shard。</p>
<p>首先我们将 gid 到 shard 做一个简单的映射，主要是从 Config 的 shards 数组中获取：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shard gid</span></span><br><span class="line"><span class="comment">//   0    1</span></span><br><span class="line"><span class="comment">//   1    1</span></span><br><span class="line"><span class="comment">//   2    2</span></span><br><span class="line"><span class="comment">//   3    2</span></span><br><span class="line"><span class="comment">//   4    1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  gid     shard</span></span><br><span class="line"><span class="comment">//   1    [0, 1, 4]</span></span><br><span class="line"><span class="comment">//   2     [2, 3]</span></span><br></pre></td></tr></table></figure>

<p>这样我们就得到了每个 gid 对应负责的 shard id。</p>
<p>然后进行前面所说的移动，这里是一个简单的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  gid     shard</span></span><br><span class="line"><span class="comment">//   1    [0, 1, 4, 8]</span></span><br><span class="line"><span class="comment">//   2    [2, 3, 7]</span></span><br><span class="line"><span class="comment">//   3    [5, 6, 9]</span></span><br><span class="line"><span class="comment">//   4    []</span></span><br><span class="line"></span><br><span class="line">-- 第一次遍历，shard 最多的是 gid <span class="number">1</span>，最少的是新加入的 gid <span class="number">4</span>，所以移动一个到 gid <span class="number">4</span></span><br><span class="line"><span class="comment">//  gid     shard</span></span><br><span class="line"><span class="comment">//   1    [1, 4, 8]</span></span><br><span class="line"><span class="comment">//   2    [2, 3, 7]</span></span><br><span class="line"><span class="comment">//   3    [5, 6, 9]</span></span><br><span class="line"><span class="comment">//   4    [0]</span></span><br><span class="line"></span><br><span class="line">-- 第二次遍历，shard 最多的是 gid <span class="number">1</span>，最少的是 gid <span class="number">4</span>，所以移动一个到 gid <span class="number">4</span></span><br><span class="line"><span class="comment">//  gid     shard</span></span><br><span class="line"><span class="comment">//   1    [4, 8]</span></span><br><span class="line"><span class="comment">//   2    [2, 3, 7]</span></span><br><span class="line"><span class="comment">//   3    [5, 6, 9]</span></span><br><span class="line"><span class="comment">//   4    [0, 1]</span></span><br><span class="line"></span><br><span class="line">-- 第三次遍历，shard 最多的是 gid <span class="number">2</span>，最少的是 gid <span class="number">1</span>，其差值等于 <span class="number">1</span>，所以结束移动，集群达到平衡</span><br></pre></td></tr></table></figure>

<p>这样移动完成之后，需要将 gid-&gt;shard id 的映射关系，重新写入到 Config 的 shards 数组中，然后存储起来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Join 加入新的 Group 到集群之中，需要处理加入之后的负载均衡问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(csm *CtrlerStateMachine)</span></span> Join(groups <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">string</span>) Err &#123;</span><br><span class="line">    num := <span class="built_in">len</span>(csm.Configs)</span><br><span class="line">    lastConfig := csm.Configs[num<span class="number">-1</span>]</span><br><span class="line">    <span class="comment">// 构建新的配置</span></span><br><span class="line">    newConfig := Config&#123;</span><br><span class="line">       Num:    num,</span><br><span class="line">       Shards: lastConfig.Shards,</span><br><span class="line">       Groups: copyGroups(lastConfig.Groups),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的 Group 加入到 Groups 中</span></span><br><span class="line">    <span class="keyword">for</span> gid, servers := <span class="keyword">range</span> groups &#123;</span><br><span class="line">       <span class="keyword">if</span> _, ok := newConfig.Groups[gid]; !ok &#123;</span><br><span class="line">          newServers := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(servers))</span><br><span class="line">          <span class="built_in">copy</span>(newServers, servers)</span><br><span class="line">          newConfig.Groups[gid] = newServers</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造 gid -&gt; shard 映射关系</span></span><br><span class="line">    gidToShards := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> gid := <span class="keyword">range</span> newConfig.Groups &#123;</span><br><span class="line">       gidToShards[gid] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// shards</span></span><br><span class="line">    <span class="comment">// shard -&gt; gid</span></span><br><span class="line">    <span class="keyword">for</span> shard, gid := <span class="keyword">range</span> newConfig.Shards &#123;</span><br><span class="line">       gidToShards[gid] = <span class="built_in">append</span>(gidToShards[gid], shard)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行 Shard 迁移</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">       maxGid, minGid := gidWithMaxShards(gidToShards), gidWithMinShards(gidToShards)</span><br><span class="line">       <span class="keyword">if</span> maxGid != <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(gidToShards[maxGid])-<span class="built_in">len</span>(gidToShards[minGid]) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 最少的 shard 的 gid 增加一个 gid</span></span><br><span class="line">       gidToShards[minGid] = <span class="built_in">append</span>(gidToShards[minGid], gidToShards[maxGid][<span class="number">0</span>])</span><br><span class="line">       <span class="comment">// 最多的 shard 的 gid 减少一个 gid</span></span><br><span class="line">       gidToShards[maxGid] = gidToShards[maxGid][<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到新的 gid -&gt; shard 信息之后， 存储到 shards 数组中</span></span><br><span class="line">    <span class="keyword">var</span> newShards [NShards]<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> gid, shards := <span class="keyword">range</span> gidToShards &#123;</span><br><span class="line">       <span class="keyword">for</span> _, shard := <span class="keyword">range</span> shards &#123;</span><br><span class="line">          newShards[shard] = gid</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    newConfig.Shards = newShards</span><br><span class="line">    csm.Configs = <span class="built_in">append</span>(csm.Configs, newConfig)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Leave-2"><a href="#Leave-2" class="headerlink" title="Leave"></a>Leave</h3><p><code>Leave</code>方法是将一个或多个 Group 从集群中删除，和 Join 一样，在删除掉集群中的 Group 之后，其负责的 shard 应该转移到其他的 Group 中，重新让集群达到均衡。</p>
<p>处理的逻辑和 Join 类似，首先我们将 gid 进行遍历，并将其从 Config 的 <code>Groups</code> 中删除，并且记录这些被删除的 gid 所对应的 shard，然后将这些 shard 分配给拥有最少 shard 的 Group。</p>
<p>这里举一个简单的例子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  gid     shard</span></span><br><span class="line"><span class="comment">//   1    [4, 8]</span></span><br><span class="line"><span class="comment">//   2    [2, 3, 7]</span></span><br><span class="line"><span class="comment">//   3    [5, 6, 9]</span></span><br><span class="line"><span class="comment">//   4    [0, 1] </span></span><br><span class="line"></span><br><span class="line">-- gid <span class="number">4</span> 离开集群之后，shard <span class="number">0</span> 和 <span class="number">1</span> 就需要重新分配</span><br><span class="line"></span><br><span class="line">-- 第一次遍历，找到拥有 shard 数最少的 gid <span class="number">1</span> 并分配</span><br><span class="line"><span class="comment">//  gid     shard</span></span><br><span class="line"><span class="comment">//   1    [4, 8, 0]</span></span><br><span class="line"><span class="comment">//   2    [2, 3, 7]</span></span><br><span class="line"><span class="comment">//   3    [5, 6, 9]</span></span><br><span class="line"></span><br><span class="line">-- 第二次遍历，找到拥有 shard 数最少的 gid <span class="number">1</span> 并分配</span><br><span class="line"><span class="comment">//  gid     shard</span></span><br><span class="line"><span class="comment">//   1    [4, 8, 0, 1]</span></span><br><span class="line"><span class="comment">//   2    [2, 3, 7]</span></span><br><span class="line"><span class="comment">//   3    [5, 6, 9]</span></span><br></pre></td></tr></table></figure>

<p>这样集群就重新达到了平衡状态，然后和 Join 一样，重新构造 Config 中的 shards 对应关系，并将其存储起来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(csm *CtrlerStateMachine)</span></span> Leave(gids []<span class="type">int</span>) Err &#123;</span><br><span class="line">    num := <span class="built_in">len</span>(csm.Configs)</span><br><span class="line">    lastConfig := csm.Configs[num<span class="number">-1</span>]</span><br><span class="line">    <span class="comment">// 构建新的配置</span></span><br><span class="line">    newConfig := Config&#123;</span><br><span class="line">        Num:    num,</span><br><span class="line">        Shards: lastConfig.Shards,</span><br><span class="line">        Groups: copyGroups(lastConfig.Groups),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 gid -&gt; shard 映射关系</span></span><br><span class="line">    gidToShards := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> gid := <span class="keyword">range</span> newConfig.Groups &#123;</span><br><span class="line">        gidToShards[gid] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> shard, gid := <span class="keyword">range</span> newConfig.Shards &#123;</span><br><span class="line">        gidToShards[gid] = <span class="built_in">append</span>(gidToShards[gid], shard)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除对应的 gid，并且将对应的 shard 暂存起来</span></span><br><span class="line">    <span class="keyword">var</span> unassignedShards []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _, gid := <span class="keyword">range</span> gids &#123;</span><br><span class="line">        <span class="comment">// 如果 gid 在数组当中，就删除掉</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := newConfig.Groups[gid]; ok &#123;</span><br><span class="line">            <span class="built_in">delete</span>(newConfig.Groups, gid)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出对应的 shard</span></span><br><span class="line">        <span class="keyword">if</span> shards, ok := gidToShards[gid]; ok &#123;</span><br><span class="line">            unassignedShards = <span class="built_in">append</span>(unassignedShards, shards...)</span><br><span class="line">            <span class="built_in">delete</span>(gidToShards, gid)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newShards [NShards]<span class="type">int</span></span><br><span class="line">    <span class="comment">// 重新分配被删除的 gid 对应的 shard</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(newConfig.Groups) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, shard := <span class="keyword">range</span> unassignedShards &#123;</span><br><span class="line">            minGId := gidWithMinShards(gidToShards)</span><br><span class="line">            gidToShards[minGId] = <span class="built_in">append</span>(gidToShards[minGId], shard)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新存储 shard 数组对应的关系</span></span><br><span class="line">    <span class="keyword">for</span> gid, shards := <span class="keyword">range</span> gidToShards &#123;</span><br><span class="line">        <span class="keyword">for</span> _, shard := <span class="keyword">range</span> shards &#123;</span><br><span class="line">            newShards[shard] = gid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置项保存</span></span><br><span class="line">    newConfig.Shards = newShards</span><br><span class="line">    csm.Configs = <span class="built_in">append</span>(csm.Configs, newConfig)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Move-2"><a href="#Move-2" class="headerlink" title="Move"></a>Move</h3><p><code>Move</code> 方法的参数是一个 shard id 和 gid，表示将这个 shard 移动的指定的 gid 之上，在这里我们的处理比较简单，因为 Config 中的 shards 关系都是明确的，只需要将 shard id 的 gid 重置为传进来的新的 gid 即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(csm *CtrlerStateMachine)</span></span> Move(shardId, gid <span class="type">int</span>) Err &#123;</span><br><span class="line">    num := <span class="built_in">len</span>(csm.Configs)</span><br><span class="line">    lastConfig := csm.Configs[num<span class="number">-1</span>]</span><br><span class="line">    <span class="comment">// 构建新的配置</span></span><br><span class="line">    newConfig := Config&#123;</span><br><span class="line">       Num:    num,</span><br><span class="line">       Shards: lastConfig.Shards,</span><br><span class="line">       Groups: copyGroups(lastConfig.Groups),</span><br><span class="line">    &#125;</span><br><span class="line">    newConfig.Shards[shardId] = gid</span><br><span class="line">    csm.Configs = <span class="built_in">append</span>(csm.Configs, newConfig)</span><br><span class="line">    <span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上部分处理完成之后，我们在状态机中的逻辑就完成了，这里可能很多人有一个疑问，那就是 Group 的 Join、Leave 只是将配置变更了，具体移动 shard 的操作应该是在哪里完成呢？</p>
<p>实际上这个是第二部分 shardkv 需要做的事情，shardkv 当中拿到配置之后，如果发现了不同，则需要处理 shard 在不同的 Group 之间的转移。</p>
<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gidWithMaxShards</span><span class="params">(gidToShards <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> shard, ok := gidToShards[<span class="number">0</span>]; ok &amp;&amp; <span class="built_in">len</span>(shard) &gt; <span class="number">0</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了让每个节点在调用的时候获取到的配置是一样的</span></span><br><span class="line">    <span class="comment">// 这里将 gid 进行排序，以确定遍历的顺序是确定的</span></span><br><span class="line">    <span class="keyword">var</span> gids []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> gid := <span class="keyword">range</span> gidToShards &#123;</span><br><span class="line">       gids = <span class="built_in">append</span>(gids, gid)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(gids)</span><br><span class="line">    maxGid, maxShards := <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> _, gid := <span class="keyword">range</span> gids &#123;</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(gidToShards[gid]) &gt; maxShards &#123;</span><br><span class="line">          maxGid, maxShards = gid, <span class="built_in">len</span>(gidToShards[gid])</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxGid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gidWithMinShards</span><span class="params">(gidToShards <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> gids []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> gid := <span class="keyword">range</span> gidToShards &#123;</span><br><span class="line">       gids = <span class="built_in">append</span>(gids, gid)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(gids)</span><br><span class="line">    minGid, minShards := <span class="number">-1</span>, NShards+<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _, gid := <span class="keyword">range</span> gids &#123;</span><br><span class="line">       <span class="keyword">if</span> gid != <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(gidToShards[gid]) &lt; minShards &#123;</span><br><span class="line">          minGid, minShards = gid, <span class="built_in">len</span>(gidToShards[gid])</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minGid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="shardkv-1"><a href="#shardkv-1" class="headerlink" title="shardkv"></a>shardkv</h1><h2 id="shardkv-单-Group-逻辑"><a href="#shardkv-单-Group-逻辑" class="headerlink" title="shardkv 单 Group 逻辑"></a>shardkv 单 Group 逻辑</h2><p>我们的 shardkv 是由多个 Replica Group 组成的，每个 Replica Group 又是由一个 raft 集群组成，使用 raft 共识算法保证数据的一致性。每个 Group 都负责了一部分 shard 的读写请求，全部的 Group 组合到一起，就是一个完整的 shardkv 服务。</p>
<p>Shardctrler 负责存储配置信息，主要是 shard 到 Group 的分配关系，当配置发生变化的时候，Group 应该根据配置处理 shard，并且这里需要保证在处理配置变更时，客户端不能看到不一致的结果。</p>
<p>客户端会通过 Get、Put、Append 这三个方法来访问 shardkv，需要保证 Put 成功之后的结果对于后续的请求是可见的，即使 Put 请求和配置变更同时发生。</p>
<p>首先我们可以处理一种最简单的情况，即集群中只有一个 Group 的情况。</p>
<p><img src="/assets/65e125362eead.png" alt="1709253906560-1.png"></p>
<p>在官方 Lab4 的提示中其实也说明了，单个 Group 的逻辑和我们在 Lab3 实现的分布式 KV 基本上是一样的，因为每个 shard 都在这个 Group 中，并不会涉及到 shard 的负载均衡。</p>
<p>所以我们可以直接参考 Lab3 的代码，实现最简单的一个版本，只不过这里我们需要修改一些逻辑，<strong>服务端需要判断 key 所属的 shard 是否在对应的 Group 中，如果不是的话则返回一个 ErrWrongGroup 错误。Clerk 中如果拿到了这个 <code>ErrWrongGroup</code> 这个错误，需要重新从 shardctrler 获取配置，然后重试请求。</strong></p>
<h3 id="Client-端"><a href="#Client-端" class="headerlink" title="Client 端"></a>Client 端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Clerk <span class="keyword">struct</span> &#123;</span><br><span class="line">    sm       *shardctrler.Clerk</span><br><span class="line">    config   shardctrler.Config</span><br><span class="line">    make_end <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> *labrpc.ClientEnd</span><br><span class="line">    <span class="comment">// You will have to modify this struct.</span></span><br><span class="line">	</span><br><span class="line">    leaderIds <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span> <span class="comment">// 记录 Leader 节点的 id，避免下一次请求的时候去轮询查找 Leader</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// clientId+SeqId 确定一条唯一的命令</span></span><br><span class="line">    clientId <span class="type">int64</span></span><br><span class="line">    seqId    <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Get(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">    args := GetArgs&#123;&#125;</span><br><span class="line">    args.Key = key</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        shard := key2shard(key)</span><br><span class="line">        gid := ck.config.Shards[shard]</span><br><span class="line">        <span class="keyword">if</span> servers, ok := ck.config.Groups[gid]; ok &#123;</span><br><span class="line">            <span class="comment">// try each server for the shard.</span></span><br><span class="line">            <span class="keyword">if</span> _, exist := ck.leaderIds[gid]; !exist &#123;</span><br><span class="line">                ck.leaderIds[gid] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            oldLeaderId := ck.leaderIds[gid]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                srv := ck.make_end(servers[ck.leaderIds[gid]])</span><br><span class="line">                <span class="keyword">var</span> reply GetReply</span><br><span class="line">                ok := srv.Call(<span class="string">&quot;ShardKV.Get&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">                <span class="keyword">if</span> ok &amp;&amp; (reply.Err == OK || reply.Err == ErrNoKey) &#123;</span><br><span class="line">                    <span class="keyword">return</span> reply.Value</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ok &amp;&amp; (reply.Err == ErrWrongGroup) &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ... not ok, or ErrWrongLeader</span></span><br><span class="line">                <span class="keyword">if</span> !ok || reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line">                    ck.leaderIds[gid] = (ck.leaderIds[gid] + <span class="number">1</span>) % <span class="built_in">len</span>(servers)</span><br><span class="line">                    <span class="keyword">if</span> ck.leaderIds[gid] == oldLeaderId &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        <span class="comment">// ask controler for the latest configuration.</span></span><br><span class="line">        ck.config = ck.sm.Query(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PutAppend"><a href="#PutAppend" class="headerlink" title="PutAppend"></a>PutAppend</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> PutAppend(key <span class="type">string</span>, value <span class="type">string</span>, op <span class="type">string</span>) &#123;</span><br><span class="line">	args := PutAppendArgs&#123;</span><br><span class="line">		ClientId: ck.clientId,</span><br><span class="line">		SeqId:    ck.seqId,</span><br><span class="line">	&#125;</span><br><span class="line">	args.Key = key</span><br><span class="line">	args.Value = value</span><br><span class="line">	args.Op = op</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		shard := key2shard(key)</span><br><span class="line">		gid := ck.config.Shards[shard]</span><br><span class="line">		<span class="keyword">if</span> servers, ok := ck.config.Groups[gid]; ok &#123;</span><br><span class="line">			<span class="comment">// try each server for the shard.</span></span><br><span class="line">			<span class="keyword">if</span> _, exist := ck.leaderIds[gid]; !exist &#123;</span><br><span class="line">				ck.leaderIds[gid] = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			oldLeaderId := ck.leaderIds[gid]</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				srv := ck.make_end(servers[ck.leaderIds[gid]])</span><br><span class="line">				<span class="keyword">var</span> reply PutAppendReply</span><br><span class="line">				ok := srv.Call(<span class="string">&quot;ShardKV.PutAppend&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">				<span class="keyword">if</span> ok &amp;&amp; reply.Err == OK &#123;</span><br><span class="line">					ck.seqId++</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> ok &amp;&amp; reply.Err == ErrWrongGroup &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// ... not ok, or ErrWrongLeader</span></span><br><span class="line">				<span class="keyword">if</span> !ok || reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line">					ck.leaderIds[gid] = (ck.leaderIds[gid] + <span class="number">1</span>) % <span class="built_in">len</span>(servers)</span><br><span class="line">					<span class="keyword">if</span> ck.leaderIds[gid] == oldLeaderId &#123;</span><br><span class="line">						<span class="keyword">break</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		<span class="comment">// ask controler for the latest configuration.</span></span><br><span class="line">		ck.config = ck.sm.Query(<span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Server-端"><a href="#Server-端" class="headerlink" title="Server 端"></a>Server 端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ShardKV <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu           sync.Mutex</span><br><span class="line">    me           <span class="type">int</span></span><br><span class="line">    rf           *raft.Raft</span><br><span class="line">    applyCh      <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line">    make_end     <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> *labrpc.ClientEnd</span><br><span class="line">    gid          <span class="type">int</span></span><br><span class="line">    ctrlers      []*labrpc.ClientEnd</span><br><span class="line">    maxraftstate <span class="type">int</span> <span class="comment">// snapshot if log grows this big</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Your definitions here.</span></span><br><span class="line">    dead           <span class="type">int32</span></span><br><span class="line">    lastApplied    <span class="type">int</span></span><br><span class="line">    shards         <span class="keyword">map</span>[<span class="type">int</span>]*MemoryKVStateMachine</span><br><span class="line">    notifyChans    <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">chan</span> *OpReply</span><br><span class="line">    duplicateTable <span class="keyword">map</span>[<span class="type">int64</span>]LastOperationInfo</span><br><span class="line">    <span class="comment">// 判断 key 所属的 shard 是否是当前所属的 group</span></span><br><span class="line">    currentConfig  shardctrler.Config  </span><br><span class="line">   	mck            *shardctrler.Clerk</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前配置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> fetchConfigTask() &#123;</span><br><span class="line">    <span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">        kv.mu.Lock()</span><br><span class="line">        newConfig := kv.mck.Query(<span class="number">-1</span>)</span><br><span class="line">        kv.currentConfig = newConfig</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        time.Sleep(FetchConfigInterval)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 key 所属的 shard 是否是当前所属的 group</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> matchGroup(key <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    shard := key2shard(key)</span><br><span class="line">    <span class="keyword">return</span> kv.currentConfig.Shards[shard] == kv.gid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="shardkv-配置变更"><a href="#shardkv-配置变更" class="headerlink" title="shardkv 配置变更"></a>shardkv 配置变更</h2><p>shardkv 需要定时从 shardctrler 这边拉取最新的配置，然后根据配置来确定哪些 shard 应该是需要进行迁移的。</p>
<p>上一节我们已经写了一个简单的拉取配置的后台任务，但是按照 lab 的提示，我们每次只能够拉取一个配置，并且按照顺序处理，这样做的目的主要是为了避免覆盖还未完成的配置变更任务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前配置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> fetchConfigTask() &#123;</span><br><span class="line">   <span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">      kv.mu.Lock()</span><br><span class="line">      newConfig := kv.mck.Query(kv.currentConfig.Num + <span class="number">1</span>)</span><br><span class="line">      kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 传入 raft 模块进行同步</span></span><br><span class="line">      kv.ConfigCommand(RaftCommand&#123;ConfigChange, newConfig&#125;, &amp;OpReply&#123;&#125;)</span><br><span class="line">      time.Sleep(FetchConfigInterval)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拉取完毕配置之后，我们需要构造一个对应的命令，然后传到 raft 模块进行同步。</p>
<p>这里需要做一点小的改造，因为我们之前传入到 raft 的都是客户端的操作，这里我们需要加上配置变更的操作。并且在 apply 协程中进行反解析。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// applyTask()</span></span><br><span class="line"><span class="keyword">var</span> opReply *OpReply</span><br><span class="line">raftCommand := message.Command.(RaftCommand)</span><br><span class="line"><span class="keyword">if</span> raftCommand.CmdType == ClientOpeartion &#123;</span><br><span class="line">   <span class="comment">// 取出用户的操作信息</span></span><br><span class="line">   op := raftCommand.Data.(Op)</span><br><span class="line">   <span class="keyword">if</span> op.OpType != OpGet &amp;&amp; kv.requestDuplicated(op.ClientId, op.SeqId) &#123;</span><br><span class="line">      opReply = kv.duplicateTable[op.ClientId].Reply</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将操作应用状态机中</span></span><br><span class="line">      shardId := key2shard(op.Key)</span><br><span class="line">      opReply = kv.applyToStateMachine(op, shardId)</span><br><span class="line">      <span class="keyword">if</span> op.OpType != OpGet &#123;</span><br><span class="line">         kv.duplicateTable[op.ClientId] = LastOperationInfo&#123;</span><br><span class="line">            SeqId: op.SeqId,</span><br><span class="line">            Reply: opReply,</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   opReply = kv.handleConfigChangeMessage(raftCommand)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据最新状态的 Config 信息，我们能够判断出当前 Group 中负责哪些 shard，也能够判断出某个 shard 转移到当前 shard 中。</p>
<p>shard</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> handleConfigChangeMessage(command RaftCommand) *OpReply &#123;</span><br><span class="line">    <span class="keyword">switch</span> command.CmdType &#123;</span><br><span class="line">    <span class="keyword">case</span> ConfigChange:</span><br><span class="line">       newConfig := command.Data.(shardctrler.Config)</span><br><span class="line">       <span class="keyword">return</span> kv.applyNewConfig(newConfig)</span><br><span class="line">    <span class="keyword">case</span> ShardMigration:</span><br><span class="line">       shardData := command.Data.(ShardOperationReply)</span><br><span class="line">       <span class="keyword">return</span> kv.applyShardMigration(&amp;shardData)</span><br><span class="line">    <span class="keyword">case</span> ShardGC:</span><br><span class="line">       shardsInfo := command.Data.(ShardOperationArgs)</span><br><span class="line">       <span class="keyword">return</span> kv.applyShardGC(&amp;shardsInfo)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       <span class="built_in">panic</span>(<span class="string">&quot;unknown config change type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func (kv *ShardKV) applyNewConfig(newConfig shardctrler.Config) *OpReply &#123;</span><br><span class="line">    if kv.currentConfig.Num+1 == newConfig.Num &#123;</span><br><span class="line">       for i := 0; i &lt; shardctrler.NShards; i++ &#123;</span><br><span class="line">          // 当前不属于 下个属于</span><br><span class="line">          if kv.currentConfig.Shards[i] != kv.gid &amp;&amp; newConfig.Shards[i] == kv.gid &#123;</span><br><span class="line">             // shard 需要迁移进来</span><br><span class="line">             gid := kv.currentConfig.Shards[i]</span><br><span class="line">             if gid != 0 &#123;</span><br><span class="line">                kv.shards[i].Status = MoveIn</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // 当前属于 下个不属于</span><br><span class="line">          if kv.currentConfig.Shards[i] == kv.gid &amp;&amp; newConfig.Shards[i] != kv.gid &#123;</span><br><span class="line">             // shard 需要迁移出去</span><br><span class="line">             gid := newConfig.Shards[i]</span><br><span class="line">             if gid != 0 &#123;</span><br><span class="line">                kv.shards[i].Status = MoveOut</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       kv.prevConfig = kv.currentConfig</span><br><span class="line">       kv.currentConfig = newConfig</span><br><span class="line">       return &amp;OpReply&#123;Err: OK&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &amp;OpReply&#123;Err: ErrWrongConfig&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">ytf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/02/29/shardkv/">http://example.com/2024/02/29/shardkv/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">ytfの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Mit6-5840/">Mit6.5840</a></div><div class="post_share"><div class="social-share" data-image="https://th.bing.com/th/id/OIP.TcbJ6d599uboFBVqWY1wKQHaEK?rs=1&amp;pid=ImgDetMain" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/02/28/lab3/" title="raftkv"><img class="cover" src="https://tse3-mm.cn.bing.net/th/id/OIP-C.aSgo02UipHGe5L9eOsmR3wHaEr?w=263&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.3&amp;pid=1.7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">raftkv</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/02/28/lab3/" title="raftkv"><img class="cover" src="https://tse3-mm.cn.bing.net/th/id/OIP-C.aSgo02UipHGe5L9eOsmR3wHaEr?w=263&h=180&c=7&r=0&o=5&dpr=1.3&pid=1.7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-28</div><div class="title">raftkv</div></div></a></div><div><a href="/2024/01/25/MapReduce/" title="MapReduce"><img class="cover" src="https://tse3-mm.cn.bing.net/th/id/OIP-C.0ZMk4njkryZvQSPeYVme9wHaFY?w=227&h=180&c=7&r=0&o=5&dpr=1.3&pid=1.7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-25</div><div class="title">MapReduce</div></div></a></div><div><a href="/2024/02/06/raft/" title="Raft"><img class="cover" src="https://img3.wallspic.com/previews/8/1/3/6/2/126318/126318-kai_hua-dan_huang-ying_hua-ji_qie-fa_xing-500x.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-06</div><div class="title">Raft</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ytf</div><div class="author-info__description">cs</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/TengFeiyang01/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/TengFeiyang01" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2196442691@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=2196442691&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #qq-color-code;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎大家来到我的博客！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-multi-raft-%E7%9A%84-shardkv-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">基于 multi raft 的 shardkv 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E8%87%B4%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">大致架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6"><span class="toc-number">1.2.</span> <span class="toc-text">代码框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shardctrler"><span class="toc-number">1.2.1.</span> <span class="toc-text">shardctrler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shardkv"><span class="toc-number">1.2.2.</span> <span class="toc-text">shardkv</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#shard-controller"><span class="toc-number">2.</span> <span class="toc-text">shard controller</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#shard-controller-%E7%9A%84-Client-%E7%AB%AF%E5%A4%84%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">shard controller 的 Client 端处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Join"><span class="toc-number">2.1.1.</span> <span class="toc-text">Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leave"><span class="toc-number">2.1.2.</span> <span class="toc-text">Leave</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Move"><span class="toc-number">2.1.3.</span> <span class="toc-text">Move</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Query"><span class="toc-number">2.1.4.</span> <span class="toc-text">Query</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shard-controller-%E7%9A%84-Server-%E7%AB%AF%E5%A4%84%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">shard controller 的 Server 端处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Command"><span class="toc-number">2.2.1.</span> <span class="toc-text">Command</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Join-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leave-1"><span class="toc-number">2.2.3.</span> <span class="toc-text">Leave</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Move-1"><span class="toc-number">2.2.4.</span> <span class="toc-text">Move</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Query-1"><span class="toc-number">2.2.5.</span> <span class="toc-text">Query</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#applyTask"><span class="toc-number">2.2.6.</span> <span class="toc-text">applyTask</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shard-controller-%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA%E5%A4%84%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">shard controller 的状态机处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Query-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">Query</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Join-2"><span class="toc-number">2.3.2.</span> <span class="toc-text">Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leave-2"><span class="toc-number">2.3.3.</span> <span class="toc-text">Leave</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Move-2"><span class="toc-number">2.3.4.</span> <span class="toc-text">Move</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.5.</span> <span class="toc-text">辅助函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#shardkv-1"><span class="toc-number">3.</span> <span class="toc-text">shardkv</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#shardkv-%E5%8D%95-Group-%E9%80%BB%E8%BE%91"><span class="toc-number">3.1.</span> <span class="toc-text">shardkv 单 Group 逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Client-%E7%AB%AF"><span class="toc-number">3.1.1.</span> <span class="toc-text">Client 端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Get"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">Get</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PutAppend"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">PutAppend</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Server-%E7%AB%AF"><span class="toc-number">3.1.2.</span> <span class="toc-text">Server 端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shardkv-%E9%85%8D%E7%BD%AE%E5%8F%98%E6%9B%B4"><span class="toc-number">3.2.</span> <span class="toc-text">shardkv 配置变更</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/29/shardkv/" title="shardkv"><img src="https://th.bing.com/th/id/OIP.TcbJ6d599uboFBVqWY1wKQHaEK?rs=1&amp;pid=ImgDetMain" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="shardkv"/></a><div class="content"><a class="title" href="/2024/02/29/shardkv/" title="shardkv">shardkv</a><time datetime="2024-02-29T02:39:32.000Z" title="发表于 2024-02-29 10:39:32">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/28/lab3/" title="raftkv"><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.aSgo02UipHGe5L9eOsmR3wHaEr?w=263&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.3&amp;pid=1.7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="raftkv"/></a><div class="content"><a class="title" href="/2024/02/28/lab3/" title="raftkv">raftkv</a><time datetime="2024-02-28T00:54:46.000Z" title="发表于 2024-02-28 08:54:46">2024-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/06/raft/" title="Raft"><img src="https://img3.wallspic.com/previews/8/1/3/6/2/126318/126318-kai_hua-dan_huang-ying_hua-ji_qie-fa_xing-500x.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Raft"/></a><div class="content"><a class="title" href="/2024/02/06/raft/" title="Raft">Raft</a><time datetime="2024-02-06T04:54:51.000Z" title="发表于 2024-02-06 12:54:51">2024-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/25/MapReduce/" title="MapReduce"><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.0ZMk4njkryZvQSPeYVme9wHaFY?w=227&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.3&amp;pid=1.7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MapReduce"/></a><div class="content"><a class="title" href="/2024/01/25/MapReduce/" title="MapReduce">MapReduce</a><time datetime="2024-01-25T11:47:16.000Z" title="发表于 2024-01-25 19:47:16">2024-01-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By ytf</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'TengFeiyang01/TengFeiyang01.github.io',
      'data-repo-id': 'R_kgDOLIXuiw',
      'data-category-id': 'DIC_kwDOLIXui84Cdoxk',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !true) {
    if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>